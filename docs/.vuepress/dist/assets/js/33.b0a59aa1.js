(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{442:function(t,s,a){"use strict";a.r(s);var v=a(33),_=Object(v.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"http基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http基础"}},[t._v("#")]),t._v(" http基础")]),t._v(" "),a("h2",{attrs:{id:"浏览器输入url按回车背后经历了哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器输入url按回车背后经历了哪些"}},[t._v("#")]),t._v(" 浏览器输入url按回车背后经历了哪些?")]),t._v(" "),a("ul",[a("li",[t._v("在浏览器地址栏输入url，先解析ulr，检测url地址是否合法")]),t._v(" "),a("li",[t._v("浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。\n"),a("ul",[a("li",[t._v("浏览器缓存:浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；")]),t._v(" "),a("li",[t._v("操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录(保存最近的DNS查询缓存)；")]),t._v(" "),a("li",[t._v("路由器缓存:如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存")]),t._v(" "),a("li",[t._v("ISP缓存:若上述均失败，继续向ISP搜索。")])])]),t._v(" "),a("li",[t._v("在发送http请求前，需要域名解析(DNS解析)，解析获取响应的IP地址")]),t._v(" "),a("li",[t._v("浏览器向服务器发送tcp链接，与浏览器简历tcp三次握手。")]),t._v(" "),a("li",[t._v("握手成功后，浏览器向服务器发送http请求，请求数据包。")]),t._v(" "),a("li",[t._v("服务器处理收到的请求，将数据返回至浏览器。")]),t._v(" "),a("li",[t._v("浏览器收到http响应。")]),t._v(" "),a("li",[t._v("浏览器解码响应，如果响应可以缓存，则存入缓存。")]),t._v(" "),a("li",[t._v("浏览器发送请求获取嵌入在HTML中的资源(html，css，JavaScript，图片，音乐......)。")]),t._v(" "),a("li",[t._v("浏览器发送异步请求。")]),t._v(" "),a("li",[t._v("页面全部渲染结束。")])]),t._v(" "),a("h2",{attrs:{id:"get和post的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get和post的区别"}},[t._v("#")]),t._v(" GET和POST的区别")]),t._v(" "),a("ul",[a("li",[t._v("GET产生的URL地址可以被Bookmark，而POST不可以。")]),t._v(" "),a("li",[t._v("GET请求会被浏览器主动cache，而POST不会，除非手动设置。")]),t._v(" "),a("li",[t._v("GET请求只能进行url编码，而POST支持多种编码方式。")]),t._v(" "),a("li",[t._v("GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。")]),t._v(" "),a("li",[t._v("GET请求在URL中传送的参数是有长度限制的，而POST么有。")]),t._v(" "),a("li",[t._v("对参数的数据类型，GET只接受ASCII字符，而POST没有限制。")]),t._v(" "),a("li",[t._v("GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。")]),t._v(" "),a("li",[t._v("GET参数通过URL传递，POST放在Request body中。")])]),t._v(" "),a("p",[t._v("GET和POST有一个重大区别，简单的说：")]),t._v(" "),a("p",[a("strong",[t._v("GET产生一个TCP数据包；POST产生两个TCP数据包。")])]),t._v(" "),a("p",[t._v("长的说：")]),t._v(" "),a("p",[a("strong",[t._v("对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；\n而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。")])]),t._v(" "),a("h3",{attrs:{id:"localstorage-与-sessionstorage-与cookie的区别总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#localstorage-与-sessionstorage-与cookie的区别总结"}},[t._v("#")]),t._v(" localStorage 与 sessionStorage 与cookie的区别总结")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("共同点")]),t._v(": 都保存在浏览器端, 且同源")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("在同一浏览器下生命周期不同")])]),t._v(" "),a("p",[t._v("Cookie生命周期: 默认是关闭浏览器后失效, 但是也可以设置过期时间")]),t._v(" "),a("p",[t._v("SessionStorage生命周期: 仅在当前会话(窗口)下有效，关闭窗口或浏览器后被清除, 不能设置过期时间")]),t._v(" "),a("p",[t._v("LocalStorage生命周期:除非被清除，否则永久保存")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("容量不同")])]),t._v(" "),a("p",[t._v("Cookie容量限制: 大小(4KB左右)和个数(20~50)")]),t._v(" "),a("p",[t._v("SessionStorage和LocalStorage容量限制: 大小(5M左右)")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("网络请求不同")])]),t._v(" "),a("p",[t._v("Cookie网络请求:每次都会携带在HTTP请求头中，如果使用cookie保存过多数据会带来性能问题")]),t._v(" "),a("p",[t._v("SessionStorage和LocalStorage网络请求: 仅在浏览器中保存，不参与和服务器的通信")])])]),t._v(" "),a("h2",{attrs:{id:"http状态码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http状态码"}},[t._v("#")]),t._v(" HTTP状态码")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[t._v("200")]),t._v(" 请求已成功，请求所希望的响应头或数据体将随此响应返回。\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("201")]),t._v(" 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("URI")]),t._v(" 已经随Location 头信息返回\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("202")]),t._v(" 服务器已接受请求，但尚未处理\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("301")]),t._v(" （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("GET")]),t._v(" 或 "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HEAD")]),t._v(" 请求的响应）时，会自动将请求者转到新位置。\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("302")]),t._v(" （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("303")]),t._v(" （查看其他位置） 请求者应当对不同的位置使用单独的 "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("GET")]),t._v(" 请求来检索响应时，服务器返回此代码。\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("304")]),t._v(" （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("305")]),t._v(" （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("307")]),t._v(" （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("401")]),t._v(" 当前请求需要用户验证。如果当前请求已经包含了 Authorization 证书，那么"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("401")]),t._v("响应代表着服务器验证已经拒绝了那些证书\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("403")]),t._v(" 服务器已经理解请求，但是拒绝执行它。与"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("401")]),t._v("响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("404")]),t._v(" 请求失败，请求所希望得到的资源未被在服务器上发现\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("500")]),t._v(" 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("501")]),t._v(" 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("502")]),t._v(" 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("503")]),t._v(" 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。\n")])])]),a("h2",{attrs:{id:"http和https区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http和https区别？"}},[t._v("#")]),t._v(" http和https区别？")]),t._v(" "),a("p",[t._v("HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是王景公司设计了SSL协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单的说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输，身份认证的网络协议，要比http协议安全。")]),t._v(" "),a("p",[t._v("主要区别如下:")]),t._v(" "),a("p",[t._v("HTTPS = SSL + HTTP")]),t._v(" "),a("ul",[a("li",[t._v("https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。")]),t._v(" "),a("li",[t._v("http是超文本传输协议，信息是明文传输，https是具有安全性的ssl加密传输协议。")]),t._v(" "),a("li",[t._v("http和https使用的完全不同的链接方式，用的端口也不一样，前者是80，后者是443。")]),t._v(" "),a("li",[t._v("http的连接很简单，是无状态的；HTTPS协议是由SSL+ HTTP协议构建的可进行加密传输，身份认证的网络协议，比如http协议安全。")])]),t._v(" "),a("h2",{attrs:{id:"什么是http协议无状态协议-怎么解决http协议无状态协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是http协议无状态协议-怎么解决http协议无状态协议"}},[t._v("#")]),t._v(" 什么是Http协议无状态协议?怎么解决Http协议无状态协议?")]),t._v(" "),a("ul",[a("li",[t._v("无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息")]),t._v(" "),a("li",[t._v("无状态协议解决办法： 通过1、Cookie 2、通过Session会话保存")])]),t._v(" "),a("h2",{attrs:{id:"三次握手和四次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三次握手和四次挥手"}},[t._v("#")]),t._v(" 三次握手和四次挥手")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/note/knowledge/tcp.html"}},[t._v("三次握手和四次挥手")])],1),t._v(" "),a("h2",{attrs:{id:"为什么连接的时候是三次握手，关闭的时候却是四次握手？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么连接的时候是三次握手，关闭的时候却是四次握手？"}},[t._v("#")]),t._v(" 为什么连接的时候是三次握手，关闭的时候却是四次握手？")]),t._v(" "),a("p",[t._v('因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。')]),t._v(" "),a("h2",{attrs:{id:"为什么time-wait状态需要经过2msl-最大报文段生存时间-才能返回到close状态？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么time-wait状态需要经过2msl-最大报文段生存时间-才能返回到close状态？"}},[t._v("#")]),t._v(" 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？")]),t._v(" "),a("p",[t._v("虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。")]),t._v(" "),a("h2",{attrs:{id:"为什么不能用两次握手进行连接？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么不能用两次握手进行连接？"}},[t._v("#")]),t._v(" 为什么不能用两次握手进行连接？")]),t._v(" "),a("p",[t._v("3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。")]),t._v(" "),a("p",[t._v("现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。")]),t._v(" "),a("h2",{attrs:{id:"如果已经建立了连接，但是客户端突然出现故障了怎么办？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如果已经建立了连接，但是客户端突然出现故障了怎么办？"}},[t._v("#")]),t._v(" 如果已经建立了连接，但是客户端突然出现故障了怎么办？")]),t._v(" "),a("p",[t._v("TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。")])])}),[],!1,null,null,null);s.default=_.exports}}]);