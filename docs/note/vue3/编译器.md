# 编译器

## compileToFunctions

```js
//编译器的入口文件 template模板 字符串   options用户配置项
var ref = compileToFunctions(template, {
    outputSourceRange: "development" !== 'production',
    // E浏览器下的bug
    shouldDecodeNewlines: shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
    //只在完整构建版本中的浏览器内编译时可用  改变纯文本插入分隔符。默认值：["{{", "}}"]
    delimiters: options.delimiters,
    //只在完整构建版本中的浏览器内编译时可用 
    //当设为 true 时，将会保留且渲染模板中的 HTML 注释。默认行为是舍弃它们。
    comments: options.comments
}, this);
var render = ref.render;
var staticRenderFns = ref.staticRenderFns;
options.render = render;
options.staticRenderFns = staticRenderFns;
```

渲染函数render就是通过compileToFunctions函数生成的，传递给该函数的第一个参数就是模板字符串,compileToFunctions函数会把模板字符串编译为渲染函数，接下来我们就将compileToFunctions函数为切入点研究编译器。


通过源码定义找到compileToFunctions的出处。

```js
var ref$1 = createCompiler(baseOptions);
var compile = ref$1.compile;
var compileToFunctions = ref$1.compileToFunctions;
```

上面代码可见compileToFunctions是createCompiler返回值对象中的一个方法createCompiler函数顾名思义它的作用就是创建一个编译器。那么编译器到底是怎么创建出来的呢？

```js
var createCompiler = createCompilerCreator(function baseCompile (
    template,
    options
) {
    //编译html  入口函数
    var ast = parse(template.trim(), options);
    if (options.optimize !== false) {
        optimize(ast, options);//diff优化
    }
    var code = generate(ast, options);//生成目标平台所需的code
    return {
        ast: ast,
        render: code.render,
        staticRenderFns: code.staticRenderFns
    }
});
```

上面代码我们得知createCompiler函数的内容是createCompilerCreator函数的返回值并且传递了baseCompile函数作为参数，也就是说通过createCompilerCreator函数创建编译器。

## createCompilerCreator

```js
function createCompilerCreator (baseCompile) {
    return function createCompiler (baseOptions) {
    function compile (
        template,
        options
    ) {
        //{} __proto__ baseOptions    权限控制
        //配置项合并， 1 用户配置对象 2 默认配置对象
        var finalOptions = Object.create(baseOptions);
        var errors = [];
        var tips = [];

        var warn = function (msg, range, tip) {
            (tip ? tips : errors).push(msg);
        };

        if (options) {
            if (options.outputSourceRange) {
                // $flow-disable-line
                var leadingSpaceLength = template.match(/^\s*/)[0].length;

                warn = function (msg, range, tip) {
                var data = { msg: msg };
                if (range) {
                    if (range.start != null) {
                    data.start = range.start + leadingSpaceLength;
                    }
                    if (range.end != null) {
                    data.end = range.end + leadingSpaceLength;
                    }
                }
                (tip ? tips : errors).push(data);
                };
            }
            // merge custom modules
            if (options.modules) {
                finalOptions.modules =
                (baseOptions.modules || []).concat(options.modules);
            }
            // merge custom directives
            if (options.directives) {
                finalOptions.directives = extend(
                Object.create(baseOptions.directives || null),
                options.directives
                );
            }
                // copy other options
                for (var key in options) {
                    if (key !== 'modules' && key !== 'directives') {
                    finalOptions[key] = options[key];
                    }
                }
            }

            finalOptions.warn = warn;

            var compiled = baseCompile(template.trim(), finalOptions);
            {
            detectErrors(compiled.ast, warn);
            }
            compiled.errors = errors;
            compiled.tips = tips;
            return compiled
        }

        return {
            compile: compile,
            compileToFunctions: createCompileToFunctionFn(compile)
        }
    }
}
```

可以看到当我们调用createCompilerCreator就会返回一个函数，这个函数就是createCompiler，调用createCompiler就可以创建一个编译器。


至此我们知道了一开始的想以compileToFunctions 作为切入点，最终的归属地就在createCompileToFunctionFn函数返回值。

```js
function createCompileToFunctionFn(compile) {
	var cache = Object.create(null);
	return function compileToFunctions(template, options, vm) {
		options = extend({}, options);
		...省略...
		return(cache[key] = res)
	}
}
```
## createCompileToFunctionFn

下面我们探索createCompileToFunctionFn是如何把模板字符串template编译成渲染函数render的。

回归Vue.prototype.$mount函数体内。
```js
var ref = compileToFunctions(template, {
	shouldDecodeNewlines: shouldDecodeNewlines,
	shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
	delimiters: options.delimiters,
	comments: options.comments
}, this);
```
在此传递给compileToFunctions第一个参数就是模板字符串template，而第二个参数则是一个配置选项options。

先说说这些配置选项中的属性

**shouldDecodeNewlines**

```js
// check whether current browser encodes a char inside attribute values
var div;

function getShouldDecode(href) {
	div = div || document.createElement('div');
	div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
	return div.innerHTML.indexOf('&#10;') > 0
}

// #3663: IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
// #6828: chrome encodes content in a[href]
var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;
```
这是什么意思呢？

在我们innerHTML获取内容时，换行符喝制表符分别被转换成了&#10和&#9。在IE中，不仅仅是a标签的href属性值，任何属性值都存在这个问题。

这就会影响Vue的编译器在对模板进行编译后的结果，为了避免这些问题Vue需要知道什么时候要做兼容工作，如果shouldDecodeNewlines为true，意味着Vue在编译模板的时候，要对属性值中的换行符或制表符做兼容处理。而shouldDecodeNewlinesForHref为true意味着Vue在编译模板的时候，要对a标签的href属性值中的换行符或制表符做兼容处理。

**options.delimiters & options.comments**

两者都是当前Vue实例$options属性，并且delimiters和comments都是 Vue 提供的选项。

**delimiters**
- 类型:`Array<string>`
- 默认值:`["{{","}}"]`
- 限制:这个选项只在完整构建版本中的浏览器内编译时可用
- 详细:改变纯文本插入分隔符

**comments**
- 类型:boolean
- 默认值:false
- 限制:这个选项只在完整构建版本中的浏览器内编译时可用。
- 详细:当设为true时，将会保留且渲染模板中的HTML注释。默认行为时舍弃它们。

搞清楚这些我们来对createCompileToFunctionFn进行解析:
```js
function createCompileToFunctionFn (compile) {
    var cache = Object.create(null);
    //template 模板字符串  options用户配置对象  {}
    return function compileToFunctions (
        template,
        options,
        vm
    ) {
    //对象拓展
    options = extend({}, options);
    var warn$$1 = options.warn || warn;//错误跟警告信息得收集  编译器内部
    delete options.warn;

    /* istanbul ignore if */
    {
        // detect possible CSP restriction
        try {
             new Function('return 1');//创建一个函数对象
        } catch (e) {
            if (e.toString().match(/unsafe-eval|CSP/)) {
                warn$$1(
                'It seems you are using the standalone build of Vue.js in an ' +
                'environment with Content Security Policy that prohibits unsafe-eval. ' +
                'The template compiler cannot work in this environment. Consider ' +
                'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
                'templates into render functions.'
                );
            }
        }
    }

    // check cache
    var key = options.delimiters
        ? String(options.delimiters) + template
        : template;
    if (cache[key]) {
        return cache[key]
    }

    // compile
    //编译完成
    var compiled = compile(template, options);

    // check compilation errors/tips
    {
        if (compiled.errors && compiled.errors.length) {//收集的编译错误信息
        if (options.outputSourceRange) {
            compiled.errors.forEach(function (e) {
                warn$$1(//控制台打印
                    "Error compiling template:\n\n" + (e.msg) + "\n\n" +
                    generateCodeFrame(template, e.start, e.end),
                    vm
                );
            });
        } else {
            warn$$1(
                "Error compiling template:\n\n" + template + "\n\n" +
                compiled.errors.map(function (e) { return ("- " + e); }).join('\n') + '\n',
                vm
            );
        }
        }
        if (compiled.tips && compiled.tips.length) {//收集提示信息
            if (options.outputSourceRange) {
                compiled.tips.forEach(function (e) { return tip(e.msg, vm); });
            } else {
                compiled.tips.forEach(function (msg) { return tip(msg, vm); });
            }
        }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);//render function 渲染函数
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
        return createFunction(code, fnGenErrors)
    });

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    {
        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
            warn$$1(
                "Failed to generate render function:\n\n" +
                fnGenErrors.map(function (ref) {
                var err = ref.err;
                var code = ref.code;

                return ((err.toString()) + " in\n\n" + code + "\n");
            }).join('\n'),
                vm
            );
        }
    }

     return (cache[key] = res)
    }
}
```
注意compileToFunctions函数是接收三个参数的，第三个参数是当前Vue实例。

首先:
```js
options = extend({}, options);
var warn$$1 = options.warn || warn;
delete options.warn;
```

通过extend把options配置对象上的属性扩展一份到新对象上，定义warn$$1变量。warn是一个错误信息提示的函数。

```js
// detect possible CSP restriction
try {
	new Function('return 1');
} catch (e) {
	if (e.toString().match(/unsafe-eval|CSP/)) {
		warn$$1(
			'It seems you are using the standalone build of Vue.js in an ' +
			'environment with Content Security Policy that prohibits unsafe-eval. ' +
			'The template compiler cannot work in this environment. Consider ' +
			'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
			'templates into render functions.'
		);
	}
}
```
使用try catch语句块对new Function('return 1')这句代码进行错误捕获，如果有错误发生且错误的内容中包含如 'unsafe-eval' 或者 'CSP' 这些字样的信息时就会给出一个警告。

CSP全称Content Security Policy ,可以直接翻译为内容安全策略，说白了，就是为了页面内容安全而制定的一系列防护策略，通过CSP所约束的规则指定可信的内容来源(这里的内容可以值脚本，图片，iframe，fton，style等等可能的远程的资源)。通过CSP协定，让WEB处于一个安全的运行环境中。


如果你的策略比较严格，那么new Funtion()将会受到影响，从而不能够使用。但是将模板字符串编译成渲染函数又依赖new Function()，所以解决方案有两个:
- 放宽你得CSP策略
- 预编译

这段代码的作用就是检测new Function()是否可用，并在某些极端情况下给你一个有用的提示。

接下来是:
```js
var key = options.delimiters ?
	String(options.delimiters) + template :
	template;
if (cache[key]) {
	return cache[key]
}
```
options.delimiters这个选项时改变纯文本插入分隔符，如果options.delimiters存在，则使用String方法将其转换成字符串并与template拼接作为key的值，否则直接使用template字符串作为key的值，然后判断`cache[key]`是否存在，如果存在直接返回`cache[key]`。

这么做的目的是缓存字符串模板的编译结果，防止重复编译，提升性能，我们在看compileToFunctions函数的最后一句代码：
`return (cache[key] = res)`。

这句代码在返回编译结果的同时，将结果缓存，这样下一次发行如果cache中存在相同的key则不需要再次编译，直接使用缓存的结果就可以了。

接下来是:
```js
// compile
var compiled = compile(template, options);

// check compilation errors/tips
if (compiled.errors && compiled.errors.length) {
	warn$$1(
		"Error compiling template:\n\n" + template + "\n\n" +
		compiled.errors.map(function(e) {
			return ("- " + e);
		}).join('\n') + '\n',
		vm
	);
   }
if (compiled.tips && compiled.tips.length) {
	compiled.tips.forEach(function(msg) {
		return tip(msg, vm);
	});
   }
}
```
compile是引用了来自createCompileToFunctionFn函数的形参稍后会重点来介绍它。

在使用compile函数对模板进行编译后会返回一个结果compiled，返回结果compiled是一个对象且这个对象可能包含两个属性errors和tips。这两个属性分别包含了编译过程中的错误和提示信息。所以上面那段代码的作用就是用来检查使用compile对模板进行编译的过程中是否存在错误和提示的，如果存在那么需要将其打印出来。

接下来是:
```js
// turn code into functions
var res = {};
var fnGenErrors = [];
res.render = createFunction(compiled.render, fnGenErrors);
res.staticRenderFns = compiled.staticRenderFns.map(function(code) {
	return createFunction(code, fnGenErrors)
});

```
res是一个空对象且它是最终的返回值，fnGenErrors是一个空数组。

在res对象上添加一个render属性，这个render属性，就是最终生成的渲染函数，它的值是通过createFuntion创建出来的。

createFunction函数源码如下:
```js
//渲染函数
function createFunction (code, errors) {
    try {
         return new Function(code)
    } catch (err) {
        errors.push({ err: err, code: code });
        return noop
    }
}
```
createFunction函数接收两个参数，第一个参数code为函数体字符串，该字符串将通过new

Function(code)的方式创建为函数。第二个参数errors是一个数组，作用是当采用new Function(code)创建函数发生错误时用来收集错误的。

已知，传递给 createFunction 函数的第一个参数是 compiled.render，所以 compiled.render 应该是一个函数体字符串，且我们知道 compiled 是 compile 函数的返回值，这说明：compile函数编译模板字符串后所得到的是字符串形式的函数体。传递给 createFunction 函数的第二个参数是之前声明的 fnGenErrors 常量，也就是说当创建函数出错时的错误信息被 push 到这个数组里了。

在这句代码之后，又在 res 对象上添加了 staticRenderFns 属性：

```js
res.staticRenderFns = compiled.staticRenderFns.map(function(code) {
	return createFunction(code, fnGenErrors)
});

```

由这段代码可知 res.staticRenderFns 是一个函数数组，是通过对compiled.staticRenderFns遍历生成的，这说明：compiled 除了包含 render 字符串外，还包含一个字符串数组staticRenderFns ，且这个字符串数组最终也通过 createFunction 转为函数。staticRenderFns 的主要作用是渲染优化，我们后面详细讲解。

最后的代码：

```js
if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
	warn$$1(
		"Failed to generate render function:\n\n" +
		fnGenErrors.map(function(ref) {
			var err = ref.err;
			var code = ref.code;

			return ((err.toString()) + " in\n\n" + code + "\n");
		}).join('\n'),
		vm
	);
}

return (cache[key] = res)

```
这段代码主要的作用是用来打印在生成渲染函数过程中的错误,返回结果的同时将结果缓存

##  compile
在 compileToFunctions 方法中:
```js
// compile
var compiled = compile(template, options);
```
而真正的编译工作是依托于compile函数，接下来我们详细解析compile。

从前面createCompilerCreator中可以看到:

`var finalOptions = Object.create(baseOptions);`

finalOptions所有的配置选项最终都会挂载在这个对象上，baseOptions包含编译器在运作的时候所需的配置选项。

```js
var baseOptions = {
	expectHTML: true,
	modules: modules$1,
	directives: directives$1,
	isPreTag: isPreTag,
	isUnaryTag: isUnaryTag,
	mustUseProp: mustUseProp,
	canBeLeftOpenTag: canBeLeftOpenTag,
	isReservedTag: isReservedTag,
	getTagNamespace: getTagNamespace,
	staticKeys: genStaticKeys(modules$1)
};
```
- 第一个属性: expectHTML 被设置为 true 。
- 第二个属性：modules
```js
var modules$1 = [
	klass$1,
	style$1,
	model$1
];

var klass$1 = {
	staticKeys: ['staticClass'],
	transformNode: transformNode,
	genData: genData
};

var style$1 = {
	staticKeys: ['staticStyle'],
	transformNode: transformNode$1,
	genData: genData$1
};

var model$1 = {
	preTransformNode: preTransformNode
};
```
- 第三个属性:directives值是三个属性(model,text,html)的对象，且属性的值都是函数。
- 第四个属性:isPreTag它是一个函数，其作用是通过给定的标签名字检查标签是否是'pre'标签。
- 第五个属性:isUnaryTag是一个通过makeMap生成的函数，该函数的作用检测给定的标签是否是一元标签。
- 第六个属性:mustUseProp它是一个函数，其作用是用来检测一个属性在标签中是否要使用props进行绑定。
- 第七个属性:canBeLeftOpenTag一个使用makeMap生成的函数，它的作用是检测非一元标签，但却可以自己补全并闭合的标签。比如 div 标签是一个双标签，你需要这样使用`<div> text </div>`，但是你依然可以省略闭合标签，直接这样写：`<div> text` ，且浏览器会自动补全。但是有些标签你不可以这样用，它们是严格的双标签。
- 第八个属性:isReservedTag它是一个函数，其作用是检查给定的标签是否是保留的标签。
- 第九个属性:getTagNamespace它也是一个函数，其作用是获取元素(标签)的命名空间。
- 第十个属性:staticKeys它的值是通过以modules为参数调用genStaticKeys函数的返回值得到的。其作用是根据编译器选项的modules选项生成一个静态键字符串。

继续往下看:
```js
var errors = [];
var tips = [];

var warn = function (msg, range, tip) {
    (tip ? tips : errors).push(msg);
};
```
在finalOptions上添加了warn方法，该方法接收两个参数:
- msg错误或提示的信息。
- tip用来表示msg是错误还是提示。

warn选项主要用在编译过程中的错误和提示收集，如果收集的信息是错误信息就将错误信息添加到前面定义的errors数组里，如果是提示信息就将其添加到tips数组里。


```js
if (options) {
	// merge custom modules
	if (options.modules) {
		finalOptions.modules =
			(baseOptions.modules || []).concat(options.modules);
	}
	// merge custom directives
	if (options.directives) {
		finalOptions.directives = extend(
			Object.create(baseOptions.directives || null),
			options.directives
		);
	}
	// copy other options
	for (var key in options) {
		if (key !== 'modules' && key !== 'directives') {
			finalOptions[key] = options[key];
		}
	}
}
```
这段代码检查 options 是否存在，这里的 options 就是使用编译器编译模板时传递的选项参数，或者可以简单理解为调用 compileToFunctions 函数时传递的选项参数。

而baseOptions理解为编译器的默认选项或者基本选项，options 是用来提供定制能力的扩展选项。而上面这段代码的作用，就是将 options 对象混合到 finalOptions 中。

两个特殊的属性处理：
- modules: 如果 options.modules 存在，就在 finalOptions 对象上添加 modules 属性，其值为 baseOptions.modules 和 options.modules 这两个数组合并后的新数组。
- directives: 对于directives 采用原型链的原理实现扩展属性对基本属性的覆盖。

```js
var compiled = baseCompile(template, finalOptions); {
	errors.push.apply(errors, detectErrors(compiled.ast));
}
compiled.errors = errors;
compiled.tips = tips;
```
上面的代码调用了 baseCompile 函数，并分别将字符串模板(template)，以及最终的编译器选项(finalOptions)传递了过去。

compiled 是 baseCompile 对模板的编译结果所以上面这段代码的作用是用来通过抽象语法树来检查模板中是否存在错误表达式的，通过 detectErrors 函数实现，将compiled.ast 作为参数传递给 detectErrors 函数，该函数最终返回一个数组，该数组中包含了所有错误的收集，最终通过这句代码将错误添加到errors。

将收集到的错误(errors)和提示(tips)添加到compiled上并返回。

baseCompile 函数是在 createCompilerCreator 函数调用时传递的实参。
```js
var createCompiler = createCompilerCreator(function baseCompile(
	template,
	options
) {
	var ast = parse(template.trim(), options);
	if (options.optimize !== false) {
		optimize(ast, options);
	}
	var code = generate(ast, options);
	return {
		ast: ast,
		render: code.render,
		staticRenderFns: code.staticRenderFns
	}
});
```

## AST
在上面代码createCompilerCreator里面可以看到baseCompile的代码非常的简短主要核心代码。

- var ast = parse(template.trim(),options);parse会用正则等方式解析template模板中的指令，class，style等数据，形成AST。
- optimize(ast, options); optimize的主要作用是标记static静态节点，这是Vue在编译过程中的一处优化，后面当update更新界面时，会有一个patch的过程，diff算法会直接跳过静态节点，从而减少了比较的过程，优化了patch的性能。
- var code = generate(ast,options);生成目标平台所需的代码，将AST转换为render function字符串的过程，得到结果是render的字符串以及staticRenderFns字符串。

最终baseCompile的返回值
```js
{
 	ast: ast,
 	render: code.render,
 	staticRenderFns: code.staticRenderFns
 }
```
最终返回了抽象语法树(ast)，渲染函数(render)，静态渲染函数(staticRenderFns)，且render的值为code.render，staticRenderFns的值为code.staticRenderFns，也就是说通过generate处理ast之后得到的返回值code是一个对象...


接下来让我们把目光聚焦在Vue的parser，它是如何将字符串模板解析成为抽象语法树(AST)的。

`var ast = parse(template.trim(), options);`

编译器的技术分为词法分析、语法分析和语义分析三个部分，通常编译器的第一项工作叫做词法分析。就像阅读文章一样，文章是由一个个的中文单词组成的。程序处理也一样，只不过这里不叫单词，而是叫做“词法记号”，英文叫 Token。

`<div id="app" v-if="ret">{{ message }}</div>`

编译器会识别出 div a span 这些标签，id class style v-if v-for 这样的属性、指令，还有花括号符号这样的插值操作...等。这些都是 Token。

那么，如何写一个程序来识别 Token 呢？

其实，我们可以手写程序制定一些规则来区分每个不同的 Token，这些规则用“正则文法”表达，符合正则文法的表达式称为“正则表达式”。通过他们来完成具体的词法分析工作。

编译器下一个阶段的工作是语法分析。词法分析是识别一个个的单词，而语法分析就是在词法分析的基础上识别出程序的语法结构。这个结构是一个树状结构，是计算机容易理解和执行的。

程序也要定义良好的语法结构，它的语法分析过程，就是构造这么一棵树。一个程序就是一棵树，这棵树叫做抽象语法树（Abstract Syntax Tree，AST）。树的每个节点（子树）是一个语法单元，这个单元的构成规则就叫“语法”。

而我们这里要讲的 parser 就是在编译器对源代码处理的第一步，parser 把某种特定格式的文本（字符串）转换成某种数据结构的程序(对象)，并且这个数据结构是编译器能够理解的，因为编译器的后续步骤，比如上面提到的 句法分析，类型检查/推导，代码优化，代码生成 等等都依赖于该数据结构。

**注：parse & parser 这两个单词，不要混淆，parse 是动词，代表“解析”的过程，parser 是名词，代表“解析器”。**

Vue 的编译器也不例外, 在词法分析阶段 Vue 会把字符串模板解析成一个个的令牌(token)，该令牌将用于句法分析阶段，在句法分析阶段会根据令牌生成一棵 AST，最后再根据该 AST生成最终的渲染函数，这样就完成了代码的生成。

`var ast = parse(template.trim(), options);`

回归到刚刚的代码，已知 parse 函数就是用来解析模板字符串的，最终生成AST。

```js
function parse(template, options) {
   // 省略...
  parseHTML(template, {
    warn,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    start (tag, attrs, unary) {
      // 省略...
    },
    end () {
      // 省略...
    },
    chars (text: string) {
      // 省略...
    },
    comment (text: string) {
      // 省略...
    }
  })
  return root
}
```

需要注意到在parse 函数内部主要通过调用parseHTML 函数对模板字符串进行解析，实际上parseHTML 函数的作用就是用来做词法分析的，而parse函数的作用则是在词法分析的基础上做句法分析从而生成一棵AST。本节我们主要分析一下Vue是如何对模板字符串进行词法分析的，也就是parseHTML 函数的实现。

## parseHTML 函数源码解析(一)
```js
function parseHTML(html, options) {
    //初始化一个空数组，在while循环中处理html字符流的时候每当遇到一个非一元标签的开始标签
    //都会将该开始标签push到该数组中。它的作用:模板中DOM结构规范性的检查
	var stack = [];
	var expectHTML = options.expectHTML;
	var isUnaryTag$$1 = options.isUnaryTag || no;//常量，用来检查一个标签是否是一元标签
	var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;//用来检查一个标签是否可以省略闭合标签的非一元标签
	var index = 0;//标识着当前字符流的读入位置
	var last, lastTag;//last存储剩余还未编译的html字符串 lastTag始终存储着位于stack栈顶元素

	// 开启一个 while 循环，循环结束的条件是 html 为空，即 html 被 parse 完毕
	while (html) {
		last = html;

		if (!lastTag || !isPlainTextElement(lastTag)) {
			// 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)
		} else {
			// parse 的内容是在纯文本标签里 (script,style,textarea)
		}

		//将整个字符串作为文本对待
		if (html === last) {
			options.chars && options.chars(html);
			if (!stack.length && options.warn) {
				options.warn(("Mal-formatted tag at end of template: \"" + html + "\""));
			}
			break
		}
	}

	// Clean up any remaining tags
	parseEndTag();

	function advance(n) {
		index += n;
		html = html.substring(n);
	}
	//parse 开始标签
	function parseStartTag() {
		//...
	}
	//处理 parseStartTag 的结果
	function handleStartTag(match) {
		//...
	}
	//parse 结束标签
	function parseEndTag(tagName, start, end) {
		//...
	}
}
```
可以看到parseHTML函数接收两个参数:html和options，其中html是要被编译的字符串，而options则是编译器所需的选项。

整体来将parseHTML分为三部分。
- 函数开头定义的一些常量和变量
- while循环
- parse过程中需要用到的analytic function

首先从第一部分开始讲起。
```js
var stack = [];
var expectHTML = options.expectHTML;
var isUnaryTag$$1 = options.isUnaryTag || no;
var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
var index = 0;
var last, lastTag;
```

第一个变量是stack，它被初始化为一个空数组，在while循环中处理html字符流的时候每当遇到一个**非单标签** ，都会将该开始标签push到该数组。它的作用模板中DOM结构规范性的检测。

但在一个html字符串中，如何判断一个非单标签是否缺少结束标签呢？

假设我们有如下`html`字符串:

`<div><p><span></p></div>`

在编译这个字符串的时候，首先会遇到div开始标签，并将该push到stack数组，然后会遇到p开始标签，并将该标签push到stack，接下来会遇到span开始标签，同样被push到stack，此时stack数组内包含三个元素。

![](/vue3/1605150242604.jpg)

再然后便会遇到p结束标签，也就是说stack栈顶的元素应该是span，如果不是span而是p，这说明span元素缺少闭合标签。

这就是检测html字符串中是否缺少闭合标签的原理。

第二个变量是expectHTML，它的值被初始化为options.expectHTML，也就是编译器选项中的expectHTML。

第三个常量是isUnaryTag，用来检测一个标签是否是一元标签。

第四个常量是canBeLeftOpenTag，用来检测一个标签是否是可以省略闭合标签的非一元标签。

- index初始化为0，标识着当前字符流的读入位置。
- last存储剩余还未编译的html字符串。
- lastTag始终存储着位于stack栈顶的元素。

接下来将进入第二部分，即开启一个while循环，循环的终止条件是html字符串为空，即html字符串全部编译完成。
```js
while (html) {
    //每次循环开始时将 html 的值赋给变量 last 用于下面比较
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {//确保即将parse得内容不是在纯文本标签里(script,style,textarea)
        var textEnd = html.indexOf('<');
        //判断第一个字符就是(<)尖括号
        if (textEnd === 0) {
        // Comment: /^<!\--/
        //如果是注释节点
        if (comment.test(html)) {
            var commentEnd = html.indexOf('-->');

            if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
                options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
            }
            advance(commentEnd + 3);
            continue
            }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        ///conditionalComment:^<!\[/
        //如果是条件注释节点
        if (conditionalComment.test(html)) {
            var conditionalEnd = html.indexOf(']>');

            if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue
            }
        }

        // Doctype:
        //如果是Doctype节点
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
            advance(doctypeMatch[0].length);
            continue
        }

        // End tag: 结束标签  <div></div> ['</div>','div']
        //第一个元素是整个匹配到的结束标签字符串，第二个元素是对应的标签名字
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
            var curIndex = index;
            advance(endTagMatch[0].length);
            //tagName start end
            parseEndTag(endTagMatch[1], curIndex, index);
            continue
        }

        // Start tag: 开始标签   如果有返回值，说明开始标签解析成功
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
            handleStartTag(startTagMatch);
            if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
            advance(1);
            }
            continue
        }
        }

        var text = (void 0), rest = (void 0), next = (void 0);
        // 第一个字符不是(<)
        if (textEnd >= 0) {
        rest = html.slice(textEnd);
        while (
            !endTag.test(rest) &&
            !startTagOpen.test(rest) &&
            !comment.test(rest) &&//注释
            !conditionalComment.test(rest)//条件注释
        ) {
            // < in plain text, be forgiving and treat it as text
            next = rest.indexOf('<', 1);
            if (next < 0) { break }
            textEnd += next;
            //从html中去除textEnd 下标元素
            rest = html.slice(textEnd);
        }
        //从html中截取0到textEnd 得原生
        text = html.substring(0, textEnd);
        }

        if (textEnd < 0) {
        text = html;
        }
        
        if (text) {
        advance(text.length);
        }

        if (options.chars && text) {
        options.chars(text, index - text.length, index);
        }
    } else {//parse得内容是在纯文本标签里面(script,style,textarea)
        var endTagLength = 0;
        var stackedTag = lastTag.toLowerCase();
        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        // isPlainTextElement=makeMap('script,style,textarea', true)
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
            text = text
            .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (shouldIgnoreFirstNewline(stackedTag, text)) {
            text = text.slice(1);
        }
        if (options.chars) {
            options.chars(text);
        }
        return ''
        });
        index += html.length - rest$1.length;
        html = rest$1;
        parseEndTag(stackedTag, index - endTagLength, index);
    }
    //讲整个字符串作为文本对待
    /**
     *  在 while 循环即将结束的时候，有一个对 last 和 html 这两个变量的比较
     * 如果相等 就说明html在经历循环得代码之后没有任何改变,
     * 此时会"Mal-formatted tag at end of template: \"" + html + "\"" 错误信息提示。
     */
    //极端情况下的处理
    if (html === last) {
        options.chars && options.chars(html);
        if (!stack.length && options.warn) {
            options.warn(("Mal-formatted tag at end of template: \"" + html + "\""), { start: index + html.length });
        }
        break
    }
}
```
首先将在每次循环开始时将html的值赋给变量last:

`last=html;`

为什么这么做？在while循环即将结束的时候，有一个对last和html这两个变量的比较，在此可以找到答案:

`if (html === last) {}`

如果两者相等，则说明html在经历循环体的代码之后没有任何改变，此时会"Mal-formatted tag at end of template: \"" + html + "\"" 错误信息提示。

接下来可以简单看下整体while循环的结构。
```js
while (html) {
  last = html
  
  if (!lastTag || !isPlainTextElement(lastTag)) {
    // parse 的内容不是在纯文本标签里
  } else {
    // parse 的内容是在纯文本标签里 (script,style,textarea)
  }

  // 极端情况下的处理
  if (html === last) {
    options.chars && options.chars(html)
    if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {
      options.warn(`Mal-formatted tag at end of template: "${html}"`)
    }
    break
  }
}
```
接下来我们重点非向这个if else中的代码:

`!lastTag || !isPlainTextElement(lastTag)`

lastTag刚刚讲到它会一直存储stack栈顶的元素，但是当编译器刚开始工作时，他只是一个空数组对象，![]==false

isPlainTextElement(lastTag) 检测 lastTag 是否为纯标签内容。

`var isPlainTextElement = makeMap('script,style,textarea', true);`

lastTag为空数组，isPlainTextElement(lastTag ) 返回false， !isPlainTextElement(lastTag) ==true。


接下来我们往下看简化版的代码。
```js
if (!lastTag || !isPlainTextElement(lastTag)) {
  var textEnd = html.indexOf('<')

  if (textEnd === 0) {
    // 第一个字符就是(<)尖括号
  }

 var text = (void 0),
     rest = (void 0),
     next = (void 0);
  if (textEnd >= 0) {
    //第一个字符不是(<)尖括号
  }

  if (textEnd < 0) {
    // 第一个字符不是(<)尖括号
  }

  if (options.chars && text) {
    options.chars(text)
  }
} else {
  // 省略 ...
}
```

当textEnd===0时，说明html字符串的第一个字符就是左尖括号，比如html字符串为:`<div>box</div>`，那么这个字符串的第一个字符就是左尖括号(<)。
```js
if (textEnd === 0) {
	// Comment: 如果是注释节点
	if (comment.test(html)) {
		var commentEnd = html.indexOf('-->');
		if (commentEnd >= 0) {
			if (options.shouldKeepComment) {
				options.comment(html.substring(4, commentEnd));
			}
			advance(commentEnd + 3);
			continue
		}
	}

	//如果是条件注释节点
	if (conditionalComment.test(html)) {
		var conditionalEnd = html.indexOf(']>');

		if (conditionalEnd >= 0) {
			advance(conditionalEnd + 2);
			continue
		}
	}

	// 如果是 Doctyp节点 
	var doctypeMatch = html.match(doctype);
	if (doctypeMatch) {
		advance(doctypeMatch[0].length);
		continue
	}

	// End tag:  结束标签
	var endTagMatch = html.match(endTag);
	if (endTagMatch) {
		var curIndex = index;
		advance(endTagMatch[0].length);
		parseEndTag(endTagMatch[1], curIndex, index);
		continue
	}

	// Start tag: 开始标签
	var startTagMatch = parseStartTag();
	if (startTagMatch) {
		handleStartTag(startTagMatch);
		if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
			advance(1);
		}
		continue
	}
}
```
重点在End tag，Start tag上。

我们先从解析标签开始分析
```js
var startTagMatch = parseStartTag();
if (startTagMatch) {
	handleStartTag(startTagMatch);
	if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
		advance(1);
	}
	continue
}
```
**parseStartTag 函数解析开始标签**

解析开始标签会调用parseStartTag函数，如果有返回值，说明开始标签解析成功。
```js
function parseStartTag() {
	var start = html.match(startTagOpen);
	if (start) {
		var match = {
			tagName: start[1],
			attrs: [],
			start: index
		};
		advance(start[0].length);
		var end, attr;
		while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
			advance(attr[0].length);
			match.attrs.push(attr);
		}
		if (end) {
			match.unarySlash = end[1];
			advance(end[0].length);
			match.end = index;
			return match
		}
	}
}
```

parseStartTag 函数首先会调用 html 字符串的 match 函数匹配 startTagOpen 正则。

如果匹配成功，那么start将是一个包含两个元素的数组:第一个元素是标签的开始部分(包含<和标签名称);第二个元素是捕获组捕获到的标签名称。比如有如下template：

`<div></div>`

start为:

`start=['<div','div']`

接下来:

定义了match变量，它是一个对象，初始化状态下拥有三个属性:
- tagName:它的值为start[1]即标签的名称。
- attrs:这个数组就是用来存储将来被匹配到的属性。
- start:初始值为index,是当前字符流读入位置在整个html字符串中的相对位置。

`advance(start[0].length)`

相对就比较简单了，它的作用就是在源字符串中截取已经编译完成的字符，我们知道当html字符为""，整个词法分析的工作就结束了，在这中间扮演重要角色的就是advance方法。
```js
function advance(n) {
	index += n;
	html = html.substring(n);
}
```

接下来:
```js
var end, attr;
while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
	advance(attr[0].length);
	match.attrs.push(attr);
}
if (end) {
	match.unarySlash = end[1];
	advance(end[0].length);
	match.end = index;
	return match
  }
}
```
主要看while循环，循环的条件有两个，第一个条件是:没有匹配到开始标签的结束部分，这个条件的实现方式主要使用了startTagClose正则，并将结果保存到end变量中。

第二个条件是:匹配到了属性，主要使用了attribute正则。

总结下这个while循环成立要素:没有匹配到开始标签的结束部分，并且匹配到了开始标签中的属性，这个时候循环体将被执行，知道遇到开始标签的结束部分为止。

接下来在循环体内做了两件事，首先调用advance函数，参数为attr[0].length即整个属性的长度。然后会将此次循环匹配到的结果push到前面定义的match对象的attrs数组中。

```js
advance(attr[0].length);
match.attrs.push(attr);
```

接下来看下最后这部分代码
```js
if (end) {
	match.unarySlash = end[1];
	advance(end[0].length);
	match.end = index;
	return match
}
```
首先判断了变量 end 是否为真，我们知道，即使匹配到了开始标签的开始部分以及属性部分但是却没有匹配到开始标签的结束部分，这说明这根本就不是一个开始标签。所以只有当变量end存在，即匹配到了开始标签的结束部分时，才能说明这是一个完整的开始标签。

如果变量end的确存在，那么将会执行 if 语句块内的代码，不过我们需要先了解一下变量end的值是什么？

比如当html（template）字符串如下时：

`<br/>`

那么匹配到的end的值为：

`end = ['/>', '/']`

比如当html（template）字符串如下时：

`<div></div>`

那么匹配到的end的值为：

`end = ['>', undefined]`

结论如果end[1]不为undefined，那么说明该标签是一个一元标签。

那么现在再看if语句块内的代码，将很容易理解，首先在match对象上添加unarySlash属性，其值为end[1]

`match.unarySlash = end[1];`

然后调用advance函数，参数为end[0].length，接着在match 对象上添加了一个end属性，它的值为index，注意由于先调用的advance函数，所以此时的index已经被更新了。最后将match 对象作为 parseStartTag 函数的返回值返回。

只有当变量end存在时，即能够确定确实解析到了一个开始标签的时候parseStartTag函数才会有返回值，并且返回值是match对象，其他情况下parseStartTag全部返回undefined。

总结：

我们模拟假设有如下html（template）字符串：

`<div id="box" v-if="watings"></div>`

则parseStartTag函数的返回值如下：
```js
match = {
  tagName: 'div',
  attrs: [
    [
      'id="box"',
      'id',
      '=',
      'box',
      undefined,
      undefined
    ],
    [
      ' v-if="watings"',
      'v-if',
      '=',
      'watings',
      undefined,
      undefined
    ]
  ],
  start: index,
  unarySlash: undefined,
  end: index
}
```

## parseHTML 函数源码解析(二) ---- parseStartTag
```js
var startTagMatch = parseStartTag();
if (startTagMatch) {
	handleStartTag(startTagMatch);
	if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
		advance(1);
	}
	continue
}
```

startTagMatch就是获取parseStartTag函数的返回值。并只有在成功匹配到开始标签的情况下parseStartTag才会返回解析结果(一个对象)，否则返回undefined。


现在我们假设匹配成功，那么if语句块中的代码将会被执行，此时会将解析结果作为参数传递给handleStartTag函数，handleStartTag源码如下:
```js
//处理parseStartTag得结果
function handleStartTag (match) {
    var tagName = match.tagName;//获取标签名
    var unarySlash = match.unarySlash;// "" or "/" 是否是一元标签

    if (expectHTML) {
        /**
         * 最近一次遇到的开始标签是 p 标签，
         * 并且当前正在解析的开始标签必须不能是段落式内容(Phrasing content)模型，
         * 这时候 if 语句块的代码才会执行，即调用parseEndTag(lastTag)
         * <p><h1></h1></p>  h1标签内容模型属于非段落式内存模型,会调用parseEndTag(lastTag)闭合p标签 =>  <p></p><h1></h1></p>  单独p标签是结束标签补全=> <p></p><h1></h1><p></p>
         */
        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
             parseEndTag(lastTag);
        }
        //判断是否可以省略闭合标签得非一元标签,并且栈顶标签与当前获取得标签是否一样
        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
            parseEndTag(tagName);
        }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
        var args = match.attrs[i];
        //args[3]=>class="id" =>单引号args[3]就有值 args[4]=>class='id' =>单引号args[4]就有值   
        //args[5]=>:class='app'=>app为变量时args[5]有值
        //前面判断都不存在的时候赋值为空的情况就是属性没有值 比如:v-once
        var value = args[3] || args[4] || args[5] || '';
        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
        ? options.shouldDecodeNewlinesForHref
        : options.shouldDecodeNewlines;
        attrs[i] = {
            name: args[1],
            value: decodeAttr(value, shouldDecodeNewlines)
        };
        if (options.outputSourceRange) {
            attrs[i].start = args.start + args[0].match(/^\s*/).length;
            attrs[i].end = args.end;
        }
    }
    /**
     * 目的:如果开始标签事非一元标签，则将该开始标签得信息入栈，
     * 即push到stack数组中，并将lastTag得值设置为该标签名
     */
    if (!unary) {
        //标签明 ，小写 ，属性
        stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });
        lastTag = tagName;
    }

    if (options.start) {
        //开始标签名字 格式化后的属性数组 是否事一元标签  开始标签在html得开始位置 结束位置
        options.start(tagName, attrs, unary, match.start, match.end);
    }
}
```
handleStartTag函数用来处理开始标签的解析结果，所以它接收parseStartTag函数的返回值作为参数。handleStartTag函数的一开始定义两个常量:tagName以及unarySlash:

```js
var tagName = match.tagName;
var unarySlash = match.unarySlash;
```

根据前面**parseHTML 函数源码解析(一)** 的内容就能理解，tagName存储解析开始标签的标签名，unarySlash可以根据他的值判断是解析的开始标签是否为一元标签。

接着是一个if语句块，if语句的判断条件是if(expectHTML),前面说过expectHTML是parser选项，是一个布尔值，如果为真则该if语句块的代码将被执行。但是现在我们暂时不看这段代码，因为这段代码包含parseEndTag函数的调用，所以待我们讲解完parseEndTag函数之后，再回头来说这段代码。

在往下定义了三个变量:
```js
var unary = isUnaryTag$$1(tagName) || !!unarySlash;

var l = match.attrs.length;
var attrs = new Array(l);
```

变量unary是一个布尔值，当它为真时代表着标签是一元标签，否则是二元标签。

他们通过isUnaryTag来判断，其原理通过传递的标签名判断是否有跟预设标准HTML中规定的哪些一元标签一致。

l 和 attrs ，其中常量 l 的值存储着 match.attrs 数组的长度，而 attrs 常量则是一个与match.attrs数组长度相等的数组。

这两个变量将被用于接下来的for循环中:
```js
for (var i = 0; i < l; i++) {
	var args = match.attrs[i];
	var value = args[3] || args[4] || args[5] || '';
	var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ?
		options.shouldDecodeNewlinesForHref :
		options.shouldDecodeNewlines;
	attrs[i] = {
		name: args[1],
		value: decodeAttr(value, shouldDecodeNewlines)
	};
}
```
具体看一下循环体的代码，首先定义 args 常量，它的值就是每个属性的解析结果，即match.attrs 数组中的元素对象。

变量 value 中就保存着最终的属性值，如果第4、5、6 项都没有获取到属性值，那么属性值将被设置为一个空字符串：''。

属性值获取到了之后，就可以拼装最终的 attrs 数组。

attrs 数组的每个元素对象只包含两个元素，即属性名 name 和属性值 value ，对于属性名直接从 args[1] 中即可获取，但我们发现属性值却没有直接使用前面获取到的 value ，而是将传value 递给了decodeAttr 函数，并使用该函数的返回值作为最终的属性值。

decodeAttr 函数的作用是对属性值中所包含的 html 实体进行解码，将其转换为实体对应的字符。

接下来:
```js
if (!unary) {
	stack.push({
		tag: tagName,
		lowerCasedTag: tagName.toLowerCase(),
		attrs: attrs
	});
	lastTag = tagName;
}
```

这个if条件是当开始标签是非一元标签时才会执行，其目的是: 如果开始标签是非一元标签，则将该开始标签的信息入栈，即push到stack数组中，并将lastTag的值设置为该标签名。

在讲解 parseHTML 函数开头定义的变量和常量的过程中，我们讲解过 stack 常量以及lastTage 变量，其目的是将来判断是否缺少闭合标签，并且现在大家应该知道为什么 lastTag 所存储的标签名字始终保存着 stack 栈顶的元素了。

最后一段代码调用parser钩子函数的：

```js
if (options.start) {
	options.start(tagName, attrs, unary, match.start, match.end);
}

```

如果 parser 选项中包含 options.start 函数，则调用之，并将开始标签的名字 tagName ，格式化后的属性数组 attrs ，是否为一元标签 unary ，以及开始标签在原 html 中的开始和结束位置match.start 和 match.end 作为参数传递。


## parseHTML 函数源码解析(三) ---- endTagMatch

```js
// End tag:
var endTagMatch = html.match(endTag);
if (endTagMatch) {
	var curIndex = index;
	advance(endTagMatch[0].length);
	parseEndTag(endTagMatch[1], curIndex, index);
	continue
}
```

首先调用html字符串得match函数匹配正则endTag，将结果保存在常量endTagMatch中。正则endTag用来匹配结束标签，并且拥有一个捕获组用来捕获标签名字，比如有如下html字符串:

`<div></div>`

endTagMatch输出如下:
```js
endTagMatch = [
  '</div>',
  'div'
]
```

第一个元素是整个匹配到得结束标签字符串，第二个元素是对应得标签名字。

如果匹配成功if语句块得代码将被执行，首先使用curIndex常量存储当前index的值，然后调用advance函数，并以endTagMatch[0].length作为参数，接着调用了parseEndTag函数对结束标签进行解析，传递给parseEndTag函数的三个参数分别是:标签名以及结束标签在html字符串中起始和结束的位置，最后调用continue语句结束此次循环。

现在我们来讲解下关键parseEndTag函数代码如下:
```js
/**
 * 作用:1.检查是否缺少闭合标签
 *     2.处理stack栈中剩余得标签
 *     3.解析</br>与p标签，与浏览器得行为相同
 */
function parseEndTag (tagName, start, end) {
    var pos, lowerCasedTagName;//pos用于判断html字符是否缺少结束标签 lowerCasedTagName用来存放tagName小写
    if (start == null) { start = index; }
    if (end == null) { end = index; }

    // Find the closest opened tag of the same type
    // 如果 tagName 不存在，则直接将 pos 设置为 0
    if (tagName) {
        lowerCasedTagName = tagName.toLowerCase();
        /**
         * for 循环从后向前遍历 stack 栈，直到找到相应的位置，
         * 并且该位置索引会保存到 pos 变量中，
         */
        for (pos = stack.length - 1; pos >= 0; pos--) {
            if (stack[pos].lowerCasedTag === lowerCasedTagName) {
                break
            }
        }
    } else {
        // If no tag name is provided, clean shop
        pos = 0;
    }
    /**
     * 两个if else条件 处理br得情况 当 tagName 没有在 stack 栈中找到对应的开始标签时，pos 为 -1  tagName为br 、p标签。
     */
    if (pos >= 0) {
        // Close all the open elements, up the stack
        for (var i = stack.length - 1; i >= pos; i--) {
            if (i > pos || !tagName &&
                options.warn
            ) {
                options.warn(
                ("tag <" + (stack[i].tag) + "> has no matching end tag."),
                { start: stack[i].start, end: stack[i].end }
                );
            }
            if (options.end) {//处理结束标签得钩子函数
                options.end(stack[i].tag, start, end);
            }
        }

        // Remove the open elements from the stack
        stack.length = pos;
        lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {//<br/>只有结束标签 
        if (options.start) {//创建描述对象 {} DOM节点
             options.start(tagName, [], true, start, end);
        }
    } else if (lowerCasedTagName === 'p') {// </p>只有结束标签 处理p标签得情况
        if (options.start) {//创建描述对象 {} DOM节点
            options.start(tagName, [], false, start, end);
        }
        if (options.end) {
             options.end(tagName, start, end);
        }
    }
}
```

你需要知道parseEndTag函数调用之前已经获得到了结束标签的名字以及结束标签在html(template)字符串中的起始和结束位置。但是这并不代表着html parser结束了。

为什么？

还记得前面说的stack栈吗？之前我们通过stack可以检测是否有非一元标签是否微写闭合标签，接下来还会处理stack栈中剩余的标签。

除了这些功能之外，parseEndTag函数还会做一件事，如果你感兴趣你可以在任何html文件中写下如下内容:
```js
<body>
  </br>
  </p>
</body>
```
上面的html片段中，我们分别写了`</br>`、`</p>`的结束标签，但注意我们并没有写起始标签，然后浏览器是能够正常解析他们的，其中 `</br>` 标签被正常解析为 `<br>` 标签，而`</p>`标签被正常解析为 `<p></p>` 。除了 br 与 p 其他任何标签如果你只写了结束标签那么浏览器都将会忽略。所以为了与浏览器的行为相同，parseEndTag 函数也需要专门处理br与p的结束标签，即：`</br>` 和`</p>`。

总结下parseEndTag 函数的作用：
- 检测是否缺少闭合标签
- 处理 stack 栈中剩余的标签
- 解析`</br>` 与`p`标签，与浏览器的行为相同

当一个函数拥有两个及以上功能的时候，最常用的技巧就是通过参数进行控制。parseEndTag 函数接收三个参数，这三个参数其实都是可选的，根据传参的不同其功能也不同。
- 第一种是处理普通的结束标签，此时三个参数都传递
- 第二种是只传递第一个参数
- 第三种是不传递参数，处理 stack 栈剩余未处理的标签。

```js
var pos, lowerCasedTagName;
if (start == null) {
	start = index;
}
if (end == null) {
	end = index;
}
```
定了两个变量:pos和lowerCasedTagName，其中变量pos会在后面用于判断html字符串是否缺少结束标签，lowerCasedTagName变量用来存储tagName的小写版。接着是两句if语句，当start和end不存在时，将这两个变量的值设置为当前字符串的读入位置，即index。所以当我们看到这两个if语句时，我们就应该能够想到:parseEndTag函数的第二个参数和第三个参数都是可选的。其实这种使用parseEndTag函数的方式我们在handleStartTag函数中见过，当时我们没有对其进行讲解一起来回顾下。
```js
if (expectHTML) {
  if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
    parseEndTag(lastTag)
  }
  if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
    parseEndTag(tagName)
  }
}
```

我们知道lastTag引用的是stack栈顶的元素，也就是最近(或者说上一次)遇到的开始标签，所以如下判断条件:

`lastTag === 'p' && isNonPhrasingTag(tagName)`

这里想表达的意思是:最近一次遇到的开始标签是p标签，并且当前正在解析的开始标签必须不能是段落式内容模型，这时候if语句块的代码才会执行，即调用parseEndTag(lastTag)。首先大家要知道每一个html元素都拥有一个或多个内容模型，其中p标签本身的内容模型是流式内容，并且p标签的特性是只允许包含段落式内容。所以条件成立的情况如下:

`<p><h1></h1></p>`

在解析上面这段html字符串的时候，首先遇到p标签的开始标签，此时lastTag被设置为p，紧接着会遇到h1标签的开始标签，由于h1标签内容模型属于非段落式内容模型，所以会立即调用parseEndTag(lastTag) 函数闭合 p 标签，此时由于强行插入了`</p>` 标签，所以解析后的字符串将变为如下内容：

`<p></p><h1></h1></p>`

接着，继续解析该字符串，会遇到`<h1></h1>`标签并正常解析之，最后解析器会遇到一个单独的p标签的结束标签，即:`</p>`。这个时候当解析器遇到p标签或者br标签的结束标签时会补全他们，最终`<p><h1></h1></p>`这段html字符串将被解析为:

`<p></p><h1></h1><p></p>`

而这也就是浏览器的行为，以上是第一个if分支的意义。还有第二个if分支，它的条件如下:

`canBeLeftOpenTag(tagName) && lastTag === tagName`

以上条件成立的意思是:当前正在解析的标签是一个可以省略结束标签的标签，并且与上一次解析到的开始标签相同，如下:

```js
<p>max
<p>kaixin
```

p 标签是可以省略结束标签的标签，所以当解析到一个p标签的开始标签并且下一次遇到的标签也是p标签的开始标签时，会立即关闭第二个p标签。即调用：parseEndTag(tagName) 函数，然后由于第一个p标签缺少闭合标签所以会Vue会给你一个警告。

```js
if (tagName) {
	lowerCasedTagName = tagName.toLowerCase();
	for (pos = stack.length - 1; pos >= 0; pos--) {
		if (stack[pos].lowerCasedTag === lowerCasedTagName) {
			break
		}
	}
} else {
	// If no tag name is provided, clean shop
	pos = 0;
}
```
如果tagName存在，lowerCasedTagName 获取的是 tagName 小写之后的值，接下来开启一个 for 循环从后向前遍历 stack 栈，直到找到相应的位置，并且该位置索引会保存到 pos 变量中，如果 tagName 不存在，则直接将 pos 设置为 0 。

开头我们讲到 pos 变量会被用来判断是否有元素缺少闭合标签。怎么做到的呢？看完下面的代码你就明白了。

```js
if (pos >= 0) {
	// Close all the open elements, up the stack
	for (var i = stack.length - 1; i >= pos; i--) {
		if (i > pos || !tagName &&
			options.warn
		) {
			options.warn(
				("tag <" + (stack[i].tag) + "> has no matching end tag.")
			);
		}
		if (options.end) {
			options.end(stack[i].tag, start, end);
		}
	}

	// Remove the open elements from the stack
	stack.length = pos;
	lastTag = pos && stack[pos - 1].tag;
} else if (lowerCasedTagName === 'br') {
	if (options.start) {
		options.start(tagName, [], true, start, end);
	}
} else if (lowerCasedTagName === 'p') {
	if (options.start) {
		options.start(tagName, [], false, start, end);
	}
	if (options.end) {
		options.end(tagName, start, end);
	}
}
```
上面代码由三部分组成，即if...else if...else if。首先我们查看 if 语句块，当 pos >= 0 的时候就会走 if 语句块。在 if 语句块内开启一个 for 循环，同样是从后向前遍历 stack 数组，如果发现 stack 数组中存在索引大于 pos 的元素，那么该元素一定是缺少闭合标签的，这个时候如果是在非生产环境那么 Vue 便会打印一句警告，告诉你缺少闭合标签。除了打印一句警告之外，随后会调用 options.end(stack[i].tag, start, end) 立即将其闭合，这是为了保证解析结果的正确性。

最后更新 stack 栈以及 lastTag
```js
stack.length = pos;
lastTag = pos && stack[pos - 1].tag;

```

了解下剩下的两个else if：
```js
if (pos >= 0) {
  // ... 省略
} else if (lowerCasedTagName === 'br') {
  if (options.start) {
    options.start(tagName, [], true, start, end)
  }
} else if (lowerCasedTagName === 'p') {
  if (options.start) {
    options.start(tagName, [], false, start, end)
  }
  if (options.end) {
    options.end(tagName, start, end)
  }
}
```

这两个else if 什么情况下成立呢?
- 当tagName没有在stack栈中找到对应的开始标签时，pos为-1。
- tagName为br，p标签。

当你写了 br 标签的结束标签：`</br>` 或 p 标签的结束标签 `</p>` 时，解析器能够正常解析他们，其中对于 `</br>` 会将其解析为正常的 `<br>` 标签，而 `</p>` 标签也会正常解析为`<p></p>`。

可以发现对于 `</br>` 和 `</p>` 标签浏览器可以将其正常解析为 `<br>` 以及`<p></p>`，Vue 的 parser 与浏览器的行为是一致的。

现在我们还剩一个问题没有讲解，即parseEndTag是如何处理stack栈中剩余未处理的标签的。其实就是调用 parseEndTag() 函数时不传递任何参数，也就是说此时 tagName 参数也不存在。这个时候我们再次查看下面的代码：

```js
if (tagName) {
  for (pos = stack.length - 1; pos >= 0; pos--) {
    if (stack[pos].lowerCasedTag === lowerCasedTagName) {
      break
    }
  }
} else {
  // If no tag name is provided, clean shop
  pos = 0
}
```
由于 pos 为 0 ，所以 i >= pos 始终成立，这个时候 stack 栈中如果有剩余未处理的标签，则会逐个警告缺少闭合标签，并调用 options.end 将其闭合。

## parseHTML 函数源码解析(四) ---- AST 基本形成
例如有html(template)字符串:
```js
<div id="app">
  <p>{{ message }}</p>
</div>
```

产出如下:
```js
{
attrs: [" id="app"", "id", "=", "app", undefined, undefined]
end: 14
start: 0
tagName: "div"
unarySlash: ""
}

{
attrs: []
end: 21
start: 18
tagName: "p"
unarySlash: ""
}
```
看到这不禁就有疑问？ 这难道就是AST(抽象语法树）？？

非常明确的告诉你答案：No 这不是我们想要的AST，parse 阶段最终生成的这棵树应该是与如上html(template)字符串的结构一一对应的：
```js
├── div
│   ├── p
│   │   ├── 文本
```

如果每一个节点我们都用一个JavaScript对象来表示的话，那么div标签可以表示为如下对象:
```js
{
  type: 1,
  tag: "div"
}
```

由于每个节点都存在一个父节点和若干子节点，所以我们为如上对象加两个属性:parent和children，分别用来表示当前节点的父节点和它所包含的子节点:
```js
{
  type: 1,
  tag:"div",
  parent: null,
  children: []
}
```

同时每个元素节点还可能包含很多属性，所以我们可以为每个节点添加attrsList属性，用来存储当前节点所拥有的属性:
```js
{
  type: 1,
  tag:"div",
  parent: null,
  children: [],
  attrsList: []
}
```

按照以上思路去描述之前定义的 html 字符串，那么这棵抽象语法树应该长成如下这个样子：
```js
{
  type: 1,
  tag: "div",
  parent: null,
  attrsList: [],
  children: [{
      type: 1,
      tag: "p",
      parent: div,
      attrsList: [],
      children:[
         {
          type: 3,
          tag:"",
          parent: p,
          attrsList: [],
          text:"{{ message }}"
         }
       ]
  }],
}
```

实际上构建抽象语法树的工作就是创建一个类似如上所示的一个能够描述节点关系的对象树，节点与节点之间通过parent和children建立联系，每个节点的type属性用来标识该节点的类别，比如type为1代表该节点为元素节点，type为3代表该节点为文本节点。


```js
function parse (html) {
  var root;
  
  parseHTML(html, {
   start: function (tag, attrs, unary) {
      // 省略...
    },
    end: function (){
      // 省略...
    }
  }) 
  return root
}
```
可以看到Vue在进行模板编译词法分析阶段调用了parse函数，parse函数返回root，其中root所代表的就是整个模板解析过后的AST，这中间还有两个非常重要的钩子函数，之前我们没有讲到的options.start 、options.end。

假设解析的html字符串如下:

`<div></div>`

这是一个没有任何子节点的div标签。如果要解析它，代码如下:
```js
function parse (html) {
  var root;
  
  parseHTML(html, {
   start: function (tag, attrs, unary) {
      var element = {
        type: 1,
        tag: tag,
        parent: null,
        attrsList: attrs,
        children: []
      }
      if (!root) root = element
    },
    end: function (){
      // 省略...
    }
  }) 
  return root
}

```

如上: 在start 钩子函数中首先定义了 element 变量，它就是元素节点的描述对象，接着判断root 是否存在，如果不存在则直接将 element 赋值给 root 。当解析这段 html 字符串时首先会遇到 div 元素的开始标签，此时 start 钩子函数将被调用，最终 root 变量将被设置为：

```js
{
  type: 1,
  tag:"div",
  parent: null,
  children: [],
  attrsList: []
}

```

html 字符串复杂度升级: 比之前的 div 标签多了一个子节点，span 标签。
```js
<div>
  <span></span>
</div>
```
此时需要把代码重新改造。

```js
function parse (html) {
  var root;
  var currentParent;

  parseHTML(html, {
   start: function (tag, attrs, unary) {
      var element = {
        type: 1,
        tag: tag,
        parent: null,
        attrsList: attrs,
        children: []
      }
      if (!root){
        root = element;
       }else if(currentParent){
        currentParent.children.push(element)
      }
      if (!unary) currentParent = element
    },
    end: function (){
      // 省略...
    }
  }) 
  return root
}
```

我们知道当解析如上 html 字符串时首先会遇到 div 元素的开始标签，此时 start 钩子函数被调用，root变量被设置为：
```js
{
  type: 1,
  tag:"div",
  parent: null,
  children: [],
  attrsList: []
}

```

还没完可以看到在 start 钩子函数的末尾有一个 if 条件语句，当一个元素为非一元标签时，会设置 currentParent 为该元素的描述对象，所以此时currentParent也是：
```js
{
  type: 1,
  tag:"div",
  parent: null,
  children: [],
  attrsList: []
}
```

接着解析 html (template)字符串，会遇到 span 元素的开始标签，此时root已经存在，currentParent 也存在，所以会将 span 元素的描述对象添加到 currentParent 的 children 数组中作为子节点，所以最终生成的 root 描述对象为：
```js
{
  type: 1,
  tag:"div",
  parent: null,
  attrsList: []
  children: [{
     type: 1,
     tag:"span",
     parent: div,
     attrsList: [],
     children:[]
  }], 
}
```

到目前为止好像没有问题，但是当html(template)字符串复杂度在升级，问题就体现出来了。

```js
<div>
 <span></span>
 <p></p>
</div>
```

在之前的基础上 div 元素的子节点多了一个 p 标签，到解析span标签的逻辑都是一样的，但是解析 p 标签时候就有问题了。

注意这个代码：

`if (!unary) currentParent = element`

在解析 p 元素的开始标签时，由于 currentParent 变量引用的是 span 元素的描述对象，所以p 元素的描述对象将被添加到 span 元素描述对象的 children 数组中，被误认为是 span 元素的子节点。而事实上 p 标签是 div 元素的子节点，这就是问题所在。

为了解决这个问题，就需要我们额外设计一个回退的操作，这个回退的操作就在end钩子函数里面实现。

这是一个什么思路呢？举个例子在解析div 的开始标签时：

`stack = [{tag:"div"...}]`

在解析span 的开始标签时：

`stack = [{tag:"div"...}]`

在解析p 的开始标签时：

`stack = [{tag:"div"...},{tag:"p"...}]`

在解析p 的标签时：

这样的一个回退操作看懂了吗？ 这就能保证在解析p开始标签的时候，stack中存储的是p标签父级元素的描述对象。

接下来继续改造我们的代码。

```js
function parse (html) {
  var root;
  var currentParent;
  var stack = [];  

  parseHTML(html, {
   start: function (tag, attrs, unary) {
      var element = {
        type: 1,
        tag: tag,
        parent: null,
        attrsList: attrs,
        children: []
      }
      if (!root){
        root = element;
       }else if(currentParent){
        currentParent.children.push(element)
      }
      if (!unary){
          currentParent = element;
          stack.push(currentParent);
       } 
    },
    end: function (){
      stack.pop();
      currentParent = stack[stack.length - 1]
    }
  }) 
  return root
}
```

通过上述代码，每当遇到一个非一元标签的结束标签时，都会回退currentParent变量的值为之前的值，这样我们就修正了当前正则解析的元素的父级元素。

**parse 函数中的变量**
```js
function parse(template, options) {
    warn$2 = options.warn || baseWarn;//打印警告信息
    //是一个编译器选项，作用是通过给定得标签名字判断该标签是否是pre标签
    platformIsPreTag = options.isPreTag || no;
    //是一个编译器选项，其作用是用来检查一个属性在标签中是否要使用元素对像原生得prop进行绑定
    platformMustUseProp = options.mustUseProp || no;
    //是一个编译器选项，作用是用来获取元素得命名空间
    platformGetTagNamespace = options.getTagNamespace || no;
    var isReservedTag = options.isReservedTag || no;
    maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };

    transforms = pluckModuleFunction(options.modules, 'transformNode');
    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
    //它的值为 options.delimiters 属性，它的值就是在创建 Vue 实例对象时所传递的 delimiters 选项。
    delimiters = options.delimiters;

    var stack = [];
    /**
     * 一个布尔值并且它的值与编译器选项中的options.preserveWhitespace选项有关，
     * 只要 options.preserveWhitespace 的值不为false，那么 preserveWhitespace 的值就为真。
     * 其中 options.preserveWhitespace 选项用来告诉编译器在编译 html 字符串时是否放弃标签之间的空格，
     * 如果为 true 则代表放弃
     */
    var preserveWhitespace = options.preserveWhitespace !== false;
    var whitespaceOption = options.whitespace;
    //存储最终生成得AST
    var root;
    //该变量维护元素描述对象之间得父子关系
    var currentParent;
    //标识当前解析的标签是否在拥有 v-pre 的标签之内
    var inVPre = false;
    // 标识当前正在解析的标签是否在 <pre></pre> 标签之内
    var inPre = false;
    /**
     * 用来打印警告信息的函数，只不过 warnOnce 函数就如它的名字一样，
     * 只会打印一次警告信息，并且 warnOnce 函数也是通过调用 warn 函数来实现的
     */
    var warned = false;

    function warnOnce(msg) {
        //...
	}

	function closeElement(element) {
       //...
	}

	parseHTML(template, {
		warn: warn$2,
		expectHTML: options.expectHTML,
		isUnaryTag: options.isUnaryTag,
		canBeLeftOpenTag: options.canBeLeftOpenTag,
		shouldDecodeNewlines: options.shouldDecodeNewlines,
		shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
		shouldKeepComment: options.comments,
		start: function start(tag, attrs, unary) {},
		end: function end() {},
		chars: function chars(text) {},
		comment: function comment(text) {},
	});
	return root

}
```

## parseHTML 函数源码解析(五) ---- start钩子函数

```js
start: function start (tag, attrs, unary, start$1, end) {
    // check namespace.
    // inherit parent ns if there is one
    //platformGetTagNamespace 判断svg或者math
    var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

    // handle IE svg bug
    /* istanbul ignore if */
    if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);//解决svg在ie上的bug
    }

    var element = createASTElement(tag, attrs, currentParent);//创建一个ast对象
    if (ns) {
         element.ns = ns;
    }

    {
    if (options.outputSourceRange) {
        element.start = start$1;
        element.end = end;
        element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
            cumulated[attr.name] = attr;
            return cumulated
        }, {});
    }
    attrs.forEach(function (attr) {
        if (invalidAttributeRE.test(attr.name)) {
            warn$2(
                "Invalid dynamic argument expression: attribute names cannot contain " +
                "spaces, quotes, <, >, / or =.",
                {
                start: attr.start + attr.name.indexOf("["),
                end: attr.start + attr.name.length
                }
            );
        }
    });
    }

    if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        warn$2(
            'Templates should only be responsible for mapping the state to the ' +
            'UI. Avoid placing tags with side-effects in your templates, such as ' +
            "<" + tag + ">" + ', as they will not be parsed.',
            { start: element.start }
        );
    }

    // apply pre-transforms 静态和非静态得属性绑定||样式得绑定
    for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
    }
    //解析指令 v-for v-if once
    if (!inVPre) {
        processPre(element);
        if (element.pre) {
            inVPre = true;
        }
    }
    if (platformIsPreTag(element.tag)) {
         inPre = true;
    }
    if (inVPre) {
        processRawAttrs(element);
    } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
    }
    //检测根节点是否符合规范
    if (!root) {
        root = element;
        {
            checkRootConstraints(root);
        }
    }

    if (!unary) {
        currentParent = element;//根节点得描述对象
        stack.push(element);//stack 在对象中构建元素节点子父级关系
    } else {
         closeElement(element);
    }
}
```
如上代码start钩子函数接受三个参数，这三个参数分别是标签名字tag，该标签的属性数组attrs，以及代表着该标签是否是一元标签的标识unary。

接下来别害怕看不懂，我们一点点来分析它函数体中的代码。

`var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);`

开头定义了ns变量，它的值为标签的命名空间，如何获取当前元素的命名空间呢？首先检测currentParent变量是否存在，我们知道currentParent变量为当前元素的父级元素描述对象，如果当前元素存在父级并且父级元素存在命名空间，则使用父级的命名空间作为当前元素的命名空间。

如果父级元素不存在或父级元素没有命名空间那么会调用platformGetTagNamespace函数，platformGetTagNamespace函数只会获取svg和math这两个的命名空间，但这两个标签的所有子标签都会继承它们两个的命名空间。

platformGetTagNamespace 源码：
```js
function getTagNamespace(tag) {
	if (isSVG(tag)) {
		return "svg"
	}
	if (tag === "math") {
		return "math"
	}
}
```

接下来源码：
```js
if (isIE && ns === "svg") {
	attrs = guardIESVGBug(attrs);
}

```

这里通过isIE来判断宿主环境是不是IE浏览器，并且前元素的命名空间为svg，如果是通过guardIESVGBug处理当前元素的属性数组attrs，并使用处理后的结果重新赋值给attrs变量。

接下来源码：
```js
var element = createASTElement(tag, attrs, currentParent);
if (ns) {
	element.ns = ns;
}
```
createASTElement 它将生成当前标签的元素描述对象并且赋值给 element 变量。紧接着检查当前元素是否存在命名空间 ns ，如果存在则在元素对象上添加 ns 属性，其值为命名空间的值。

接下来源码：
```js
if (isForbiddenTag(element) && !isServerRendering()) {
	element.forbidden = true;
	warn$2(
		'Templates should only be responsible for mapping the state to the ' +
		'UI. Avoid placing tags with side-effects in your templates, such as ' +
		"<" + tag + ">" + ', as they will not be parsed.'
	);
}
```
这里的作用就是判断在非服务端渲染情况下，当前解析的开始标签是否是禁止在模板中使用的标签。哪些是禁止的呢？

看 isForbiddenTag 函数：
```js
function isForbiddenTag(el) {
	return (
		el.tag === 'style' ||
		(el.tag === 'script' && (
			!el.attrsMap.type ||
			el.attrsMap.type === 'text/javascript'
		))
	)
}
```

可以看到，style，script 都是在禁止名单中，但通过isForbiddenTag 也发现一个彩蛋。

```js
<script type="text/x-template" id="hello-world-template">
  <p>Hello hello hello</p>
</script>
```

当定义模板的方式如上，在 `<script>` 元素上添加 type="text/x-template" 属性。 此时的script不会被禁止。

最后还会在当前元素的描述对象上添加 element.forbidden 属性，并将其值设置为true。

接下来源码：
```js
for (var i = 0; i < preTransforms.length; i++) {
	element = preTransforms[i](element, options) || element;
}
```

如上代码中使用 for 循环遍历了preTransforms 数组，preTransforms 是通过pluckModuleFunction 函数从options.modules 选项中筛选出名字为preTransformNode 函数所组成的数组。实际上 preTransforms 数组中只有一个 preTransformNode 函数该函数只用来处理 input 标签我们在后面章节会来讲它。

接下来源码：
```js
if (!inVPre) {
	processPre(element);
	if (element.pre) {
		inVPre = true;
	}
}
if (platformIsPreTag(element.tag)) {
	inPre = true;
}
if (inVPre) {
	processRawAttrs(element);
} else if (!element.processed) {
	// structural directives
	processFor(element);
	processIf(element);
	processOnce(element);
	// element-scope stuff
	processElement(element, options);
}
```

可以看到这里会有大量的process*的函数，这些函数是做什么用的呢？实际上process* 系列函数的作用就是对元素描述对象做进一步处理，比如其中一个函数叫做 processPre，这个函数的作用就是用来检测元素是否拥有v-pre 属性，如果有v-pre 属性则会在 element 描述对象上添加一个 pre 属性，如下：
```js
{
  type: 1,
  tag,
  attrsList: attrs,
  attrsMap: makeAttrsMap(attrs),
  parent,
  children: [],
  pre: true
}
```

总结：所有process* 系列函数的作用都是为了让一个元素的描述对象更加充实，使这个对象能更加详细地描述一个元素， 不过我们本节主要总结解析一个开始标签需要做的事情，所以稍后去看这些代码的实现。

接下来源码：
```js
function checkRootConstraints(el) {
	{
		if (el.tag === 'slot' || el.tag === 'template') {
			warnOnce(
				"Cannot use <" + (el.tag) + "> as component root element because it may " +
				'contain multiple nodes.'
			);
		}
		if (el.attrsMap.hasOwnProperty('v-for')) {
			warnOnce(
				'Cannot use v-for on stateful component root element because ' +
				'it renders multiple elements.'
			);
		}
	}
}
```

我们知道在编写 Vue 模板的时候会受到两种约束，首先模板必须有且仅有一个被渲染的根元素，第二不能使用 slot 标签和 template 标签作为模板的根元素。

checkRootConstraints 函数内部首先通过判断 el.tag === 'slot' || el.tag === 'template' 来判断根元素是否是slot 标签或 template 标签，如果是则打印警告信息。接着又判断当前元素是否使用了 v-for 指令，因为v-for 指令会渲染多个节点所以根元素是不允许使用 v-for 指令的。

接下来源码：
```js
if (!root) {
	root = element;
	checkRootConstraints(root);
} else if (!stack.length) {
	// allow root elements with v-if, v-else-if and v-else
	if (root.if && (element.elseif || element.else)) {
		checkRootConstraints(element);
		addIfCondition(root, {
			exp: element.elseif,
			block: element
		});
	} else {
		warnOnce(
			"Component template should contain exactly one root element. " +
			"If you are using v-if on multiple elements, " +
			"use v-else-if to chain them instead."
		);
	}
}
```
这个 if 语句先检测 root 是否存在！我们知道 root 变量在一开始是不存在的，如果 root 不存在那说明当前元素应该就是根元素，所以在 if 语句块内直接把当前元素的描述对象 element 赋值给 root 变量，同时会调用 checkRootConstraints函数检查根元素是否符合要求。

再来看 else if 语句的条件，当 stack 为空的情况下会执行 else if 语句块内的代码, 那stack 什么情况下才为空呢？前面已经多次提到每当遇到一个非一元标签时就会将该标签的描述对象放进数组，并且每当遇到一个结束标签时都会将该标签的描述对象从 stack 数组中拿掉，那也就是说在只有一个根元素的情况下，正常解析完成一段 html 代码后 stack 数组应该为空，或者换个说法，即当 stack 数组被清空后则说明整个模板字符串已经解析完毕了，但此时 start 钩子函数仍然被调用了，这说明模板中存在多个根元素，这时 else if 语句块内的代码将被执行：

接下来源码：
```js
if (root.if && (element.elseif || element.else)) {
	checkRootConstraints(element);
	addIfCondition(root, {
		exp: element.elseif,
		block: element
	});
} else {
	warnOnce(
		"Component template should contain exactly one root element. " +
		"If you are using v-if on multiple elements, " +
		"use v-else-if to chain them instead."
	);

}

```

想要能看懂这个代码，你需要懂一些前置知识。

[Vue条件渲染](https://cn.vuejs.org/v2/guide/conditional.html)

我们知道在编写 Vue 模板时的约束是必须有且仅有一个被渲染的根元素，但你可以定义多个根元素，只要能够保证最终只渲染其中一个元素即可，能够达到这个目的的方式只有一种，那就是在多个根元素之间使用 v-if 或 v-else-if 或 v-else 。

示例代码:
```js
<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Not A/B/C
</div>
```

在回归到代码部分。

`if (root.if && (element.elseif || element.else))`

root 对象中的 .if 属性、.elseif 属性以及 .else 属性都是哪里来的，它们是在通过 processIf 函数处理元素描述对象时，如果发现元素的属性中有 v-if 或 v-else-if 或 v-else ，则会在元素描述对象上添加相应的属性作为标识。

上面代码如果第一个根元素上有 .if 的属性，而非第一个根元素 element 有 .elseif 属性或者 .else 属性，这说明根元素都是由 v-if、v-else-if、v-else 指令控制的，同时也保证了被渲染的根元素只有一个。

接下来继续看：
```js
if (root.if && (element.elseif || element.else)) {
	checkRootConstraints(element);
	addIfCondition(root, {
		exp: element.elseif,
		block: element
	});
} else {
	warnOnce(
		"Component template should contain exactly one root element. " +
		"If you are using v-if on multiple elements, " +
		"use v-else-if to chain them instead."
	);
}

```

checkRootConstraints 函数检查当前元素是否符合作为根元素的要求，这都能理解。

addIfCondition是什么，看下它的源代码。

```js
function addIfCondition(el, condition) {
	if (!el.ifConditions) {
		el.ifConditions = [];
	}
	el.ifConditions.push(condition);
}
```

代码很简单，调用addIfCondition 传递的参数 root 对象，在函数体中扩展一个属性addIfCondition， root.addIfCondition 属性值是一个对象。 此对象中有两个属性exp、block。实际上该函数是一个通用的函数，不仅仅用在根元素中，它用在任何由 v-if、v-else-if 以及 v-else 组成的条件渲染的模板中。

通过如上分析我们可以发现，具有 v-else-if 或 v-else 属性的元素的描述对象会被添加到具有 v-if 属性的元素描述对象的 .ifConnditions 数组中。

举个例子，如下模板：
```js
<div v-if="A"></div>
<div v-else-if="B"></div>
<div v-else-if="C"></div>
<div v-else></div>
```

解析后生成的 AST 如下(简化版)：
```js
{
  type: 1,
  tag: 'div',
  ifConditions: [
    {
      exp: 'A',
      block: { type: 1, tag: 'div' /* 省略其他属性 */ }
    },
    {
      exp: 'B',
      block: { type: 1, tag: 'div' /* 省略其他属性 */ }
    },
    {
      exp: 'C',
      block: { type: 1, tag: 'div' /* 省略其他属性 */ }
    },
    {
      exp: 'undefined',
      block: { type: 1, tag: 'div' /* 省略其他属性 */ }
    }
  ]
  // 省略其他属性...
}
```

假如当前元素不满足条件：root.if && (element.elseif || element.else) ，那么在非生产环境下会打印了警告信息。

接下来源码:
```js
if (currentParent && !element.forbidden) {
	if (element.elseif || element.else) {
		processIfConditions(element, currentParent);
	} else if (element.slotScope) { // scoped slot
		currentParent.plain = false;
		var name = element.slotTarget || '"default"';
		(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
	} else {
		currentParent.children.push(element);
		element.parent = currentParent;
	}
}
if (!unary) {
	currentParent = element;
	stack.push(element);
} else {
	closeElement(element);
}
```

我们先从下往上讲, 为什么呢？原因是在解析根元素的时候currentParent并没有赋值。

!unary 表示解析的是非一元标签，此时把该元素的描述对象添加到stack 栈中，并且将 currentParent 变量的值更新为当前元素的描述对象。如果一个元素是一元标签，那么应该调用 closeElement 函数闭合该元素。

老生常谈的总结：每当遇到一个非一元标签都会将该元素的描述对象添加到stack数组，并且currentParent 始终存储的是 stack 栈顶的元素，即当前解析元素的父级。

```js
if (currentParent && !element.forbidden) {
	if (element.elseif || element.else) {
		processIfConditions(element, currentParent);
	} else if (element.slotScope) { // scoped slot
		currentParent.plain = false;
		var name = element.slotTarget || '"default"';
		(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
	} else {
		currentParent.children.push(element);
		element.parent = currentParent;
	}
}
```

这里的条件要成立，则说明当前元素存在父级( currentParent )，并且当前元素不是被禁止的元素。

常见的情况如下：

```js
if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
         //...
	} else if (element.slotScope) { // scoped slot
	 //...
	} else {
		currentParent.children.push(element);
		element.parent = currentParent;
	}
}
```

在 else 语句块内，会把当前元素描述对象添加到父级元素描述对象 ( currentParent ) 的children 数组中，同时将当前元素对象的 parent 属性指向父级元素对象，这样就建立了元素描述对象间的父子级关系。

如果一个标签使用 v-else-if 或 v-else 指令，那么该元素的描述对象实际上会被添加到对应的v-if 元素描述对象的 ifConditions 数组中，而非作为一个独立的子节点，这个工作就是由如下代码完成：

```js
if (currentParent && !element.forbidden) {
	if (element.elseif || element.else) {
		processIfConditions(element, currentParent);
	} else if (element.slotScope) { // scoped slot
		currentParent.plain = false;
		var name = element.slotTarget || '"default"';
		(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
	} else {
	  //...
	}
}
```

如当前解析的元素使用了 v-else-if 或 v-else 指令，则会调用 processIfConditions 函数，同时将当前元素描述对象 element 和父级元素的描述对象 currentParent 作为参数传递：

processIfConditions 源码
```js
function processIfConditions(el, parent) {
	var prev = findPrevElement(parent.children);
	if (prev && prev.if) {
		addIfCondition(prev, {
			exp: el.elseif,
			block: el
		});
	} else {
		warn$2(
			"v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
			"used on element <" + (el.tag) + "> without corresponding v-if."
		);
	}
}

```

findPrevElement 函数是去查找到当前元素的前一个元素描述对象，并将其赋值给 prev 常量，addIfCondition 不用多说如果prev 、prev.if 存在，调用 addIfCondition 函数在当前元素描述对象添加 ifConditions 属性，传入的对象存储相关信息。

如果当前元素没有使用 v-else-if 或 v-else 指令，那么还会判断当前元素是否使用了 slot-scope 特性，如下：
```js
if (currentParent && !element.forbidden) {
	if (element.elseif || element.else) {
          //...
	} else if (element.slotScope) { // scoped slot
		currentParent.plain = false;
		var name = element.slotTarget || '"default"';
		(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
	} else {
	  //...
	}
}

```
如果一个元素使用了 slot-scope 特性，那么该元素的描述对象会被添加到父级元素的scopedSlots 对象下，也就是说使用了 slot-scope 特性的元素与使用了v-else-if 或 v-else 指令的元素一样，他们都不会作为父级元素的子节点，对于使用了 slot-scope 特性的元素来讲它们将被添加到父级元素描述对象的 scopedSlots 对象下。

## parseHTML 函数源码解析(五) chars、end、comment钩子函数

```js
chars: function chars (text, start, end) {
    /**
     * 判断当前节点的父节点是否存在
     * 如果不存在说明:
     * 1.没有根元素，只有文本
     * 2.文本在根元素之外
     */
    if (!currentParent) {
        {
            if (text === template) {
                warnOnce(
                    'Component template requires a root element, rather than just text.',
                    { start: start }
                );
            } else if ((text = text.trim())) {
                warnOnce(
                    ("text \"" + text + "\" outside root element will be ignored."),
                    { start: start }
                );
            }
        }
         return
    }
    // IE textarea placeholder bug
    /* istanbul ignore if */
    if (isIE &&
        currentParent.tag === 'textarea' &&
        currentParent.attrsMap.placeholder === text
    ) {
        return
    }
    var children = currentParent.children;
    /**
     * 如果为 true，检测了当前文本节点的父节点是否是文本标签，
     * 如果是文本标签则直接使用原始文本，否则使用decodeHTMLCached 函数对文本进行解码
     */
    if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
    } else if (!children.length) {
        // remove the whitespace-only node right after an opening tag
        text = '';
    } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
            // in condense mode, remove the whitespace node if it contains
            // line break, otherwise condense to a single space
            text = lineBreakRE.test(text) ? '' : ' ';
        } else {
            text = ' ';
        }
    } else {
         text = preserveWhitespace ? ' ' : '';
    }
    if (text) {
        if (!inPre && whitespaceOption === 'condense') {
            // condense consecutive whitespaces into single space
            text = text.replace(whitespaceRE$1, ' ');
        }
        var res;
        var child;
        //判断当前元素未使用v-pre 指令，text不为空，使用 parseText 函数成功解析当前文本节点的内容
        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
            child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text//原始的文本内容
            };
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
            /**
             * 文本内容不是空格
            文本内容是空格，但是该文本节点的父节点还没有子节点(即 !children.length )
            文本内容是空格，并且该文本节点的父节点有子节点，但最后一个子节点不是空格

            */
            child = {
            type: 3,
            text: text
            };
        }
        if (child) {
            if (options.outputSourceRange) {
            child.start = start;
            child.end = end;
            }
            children.push(child);
        }
    }
},
```

当解析器遇到文本节点时，如上代码中的 chars 钩子函数就会被调用，并且接收该文本节点的文本内容作为参数。

我们来看chars钩子函数最开始的这段代码：
```js
if (!currentParent) {
	{
		if (text === template) {
			warnOnce(
				'Component template requires a root element, rather than just text.'
			);
		} else if ((text = text.trim())) {
			warnOnce(
				("text \"" + text + "\" outside root element will be ignored.")
			);
		}
	}
	return
}
```
首先判断了 currentParent 变量是否存在，我们知道 currentParent 变量指向的是当前节点的父节点:。

如果 currentParent 变量不存在说明什么问题？
- 没有根元素，只有文本。
- 文本在根元素之外。

当遇到第一种情况打印警告信息:"模板必须要有根元素"，第二种情况打印警告信息:" 根元素外的文本将会被忽略"。

接下来：
```js
if (isIE &&
	currentParent.tag === 'textarea' &&
	currentParent.attrsMap.placeholder === text
) {
	return
}
```
这段代码是用来解决 IE 浏览器中渲染 `<textarea>` 标签的 placeholder 属性时存在的 bug 的。具体的问题大家可以在这个 [issue](https://github.com/vuejs/vue/issues/4098) 查看。

接下来是个嵌套三元表达式：
```js
var children = currentParent.children;
text = inPre || text.trim() ?
	isTextTag(currentParent) ? text : decodeHTMLCached(text)
	// only preserve whitespace if its not right after a starting tag
	:
	preserveWhitespace && children.length ? ' ' : '';

```

这个嵌套三元表达式判断了条件 inPre || text.trim() 的真假，如果为 true，检测了当前文本节点的父节点是否是文本标签，如果是文本标签则直接使用原始文本，否则使用decodeHTMLCached 函数对文本进行解码。

inPre || text.trim() 如果为 false，检测 preserveWhitespace 是否为 true 。preserveWhitespace 是一个布尔值代表着是否保留空格，只有它为真的情况下才会保留空格。但即使 preserveWhitespace 常量的值为真，如果当前节点的父节点没有子元素则也不会保留空格，换句话说，编译器只会保留那些 不存在于开始标签之后的空格。

接下来：
```js
if (text) {
	var res;
	if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
		children.push({
			type: 2,
			expression: res.expression,
			tokens: res.tokens,
			text: text
		});
	} else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
		children.push({
			type: 3,
			text: text
		});
	}
}
```

这里相当就比较简单了一个 if else if 操作，第一个 if 判断当前元素未使用v-pre 指令，text不为空，使用 parseText 函数成功解析当前文本节点的内容。

对于前两个条件很好理解，关键在于 parseText 函数能够成功解析文本节点的内容说明了什么，如下示例代码：

`<div> hello: {{ message }} </div>`

如上模板中存在的文本节点包含了 Vue 语法中的字面量表达式，而 parseText 函数的作用就是用来解析这段包含了字面量表达式的文本的。此时会执行以下代码创建一个类型为2(type = 2) 的元素描述对象：
```js
children.push({
	type: 2,
	expression: res.expression,
	tokens: res.tokens,
	text: text
});

```

注意：类型为 2 的元素描述对象拥有三个特殊的属性，分别是 expression 、tokens 以及text ，其中 text 就是原始的文本内容，而 expression 和 tokens 的值是通过 parseText 函数解析的结果中读取的。

后面我们专门会讲讲parseText函数，接下来继续看下如果上列的 if 判断失败出现的三种可能性。

- 当前解析的元素使用v-pre 指令
- text 为空
- parseText 解析失败

只要以上三种情况中，有一种情况出现则代码会来到else...if 分支的判断，如下：
```js
else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
	children.push({
		type: 3,
		text: text
	});
 }
```

如果满足 else if 中的条件直接，创建一个类型为3(type = 3) 的元素描述对象：类型为3 的元素描述对象只拥有一个的属性text存储原始的文本内容。

在看下要满足 else if 中的这些条件吧！

- 文本内容不是空格
- 文本内容是空格，但是该文本节点的父节点还没有子节点(即 !children.length )
- 文本内容是空格，并且该文本节点的父节点有子节点，但最后一个子节点不是空格

接下来我们来聊聊之前讲到的parseText 函数。

**parseText**

```js
function parseText(
	text,
	delimiters
) {
	var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
	if (!tagRE.test(text)) {
		return
	}
	var tokens = [];
	var rawTokens = [];
	var lastIndex = tagRE.lastIndex = 0;
	var match, index, tokenValue;
	while ((match = tagRE.exec(text))) {
		index = match.index;
		// push text token
		if (index > lastIndex) {
			rawTokens.push(tokenValue = text.slice(lastIndex, index));
			tokens.push(JSON.stringify(tokenValue));
		}
		// tag token
		var exp = parseFilters(match[1].trim());
		tokens.push(("_s(" + exp + ")"));
		rawTokens.push({
			'@binding': exp
		});
		lastIndex = index + match[0].length;
	}
	if (lastIndex < text.length) {
		rawTokens.push(tokenValue = text.slice(lastIndex));
		tokens.push(JSON.stringify(tokenValue));
	}
	return {
		expression: tokens.join('+'),
		tokens: rawTokens
	}
}
```

parseText 接收两个参数 text 要解析的文本，delimiters 是编译器的一个用户自定义选项[delimiters](https://cn.vuejs.org/v2/api/#delimiters) ，通过它可以改变文本插入分隔符。所以才有了如下代码。

`var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;`

这里是解析文本所用正则之间的一个较量，delimiters 有值就调用buildRegex函数，我们默认是没有值，使用 defaultTagRE 来解析文本。

`var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;`

这个正则还是非常简单，接下来会判断，如果文本中没有与正则相匹配的文本直接直接终止函数的执行。

```js
if (!tagRE.test(text)) {
    return
}
```

接下来代码就有意思了一起看下。
```js
var tokens = [];
var rawTokens = [];
var lastIndex = tagRE.lastIndex = 0;
var match, index, tokenValue;
while ((match = tagRE.exec(text))) {
	index = match.index;
	// push text token
	if (index > lastIndex) {
		rawTokens.push(tokenValue = text.slice(lastIndex, index));
		tokens.push(JSON.stringify(tokenValue));
	}
	// tag token
	var exp = parseFilters(match[1].trim());
	tokens.push(("_s(" + exp + ")"));
	rawTokens.push({
		'@binding': exp
	});
	lastIndex = index + match[0].length;
}
if (lastIndex < text.length) {
	rawTokens.push(tokenValue = text.slice(lastIndex));
	tokens.push(JSON.stringify(tokenValue));
}
return {
	expression: tokens.join('+'),
	tokens: rawTokens
}
```

这段代码不难，初始定义了一系列变量。 接着开启一个while循环，使用 tagRE 正则匹配文本内容，并将匹配结果保存在 match 变量中，直到匹配失败循环才会终止，这时意味着所有的字面量表达式都已经处理完毕了。

在这个while循环结束返回一个对象，expression、tokens分别存储解析过程中的信息。

假设文本如下:

`<div id="app">hello {{ message }}</div>`

parseText 解析文本后返回的对象。

```js
{
  expression: "'hello'+_s(message)",
  tokens: [
    'hello',
    {
      '@binding': 'message'
    }
  ]
}
```

接下来我们聊聊对结束标签的处理。

end 源码：
```js
end: function end() {
	// remove trailing whitespace
	var element = stack[stack.length - 1];
	var lastNode = element.children[element.children.length - 1];
	if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
		element.children.pop();
	}
	// pop stack
	stack.length -= 1;
	currentParent = stack[stack.length - 1];
	closeElement(element);
}
```

end 钩子函数，当解析 html 字符串遇到结束标签的时候，。那么在 end 钩子函数中都需要做哪些事情呢？

在之前的文章中我们讲过解析器遇到非一元标签的开始标签时，会将该标签的元素描述对象设置给 currentParent 变量，代表后续解析过程中遇到的所有标签都应该是 currentParent 变量所代表的标签的子节点，同时还会将该标签的元素描述对象添加到 stack 栈中。而当遇到结束标签的时候则意味着 currentParent 变量所代表的标签以及其子节点全部解析完毕了，此时我们应该把 currentParent 变量的引用修改为当前标签的父标签，这样我们就将作用域还原给了上层节点，以保证解析过程中正确的父子关系。

下面代码就是来完成这个工作:
```js
stack.length -= 1;
currentParent = stack[stack.length - 1];
closeElement(element);
```

首先将当前节点出栈：stack.length -= 1 什么意思呢？

看一个代码就懂了。
```js
var arr = [1,2,3,4];
arr.length-=1;

>arr [1,2,3]
```

接着读取出栈后 stack 栈中的最后一个元素作为 currentParent 变量的值。 那closeElement 函数是做什么用的呢？

closeElement 源码：
```js
function closeElement(element) {
	// check pre state
	if (element.pre) {
		inVPre = false;
	}
	if (platformIsPreTag(element.tag)) {
		inPre = false;
	}
	// apply post-transforms
	for (var i = 0; i < postTransforms.length; i++) {
		postTransforms[i](element, options);
	}
}

```

closeElement 的作用有两个：第一个是对数据状态的还原，第二个是调用后置处理转换钩子函数。

接下来看下end函数中剩余代码：
```js
// remove trailing whitespace
var element = stack[stack.length - 1];
var lastNode = element.children[element.children.length - 1];
if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
    element.children.pop();
}

```

这个代码的作用是去除当前元素最后一个空白子节点，我们在讲解 chars 钩子函数时了解到：preserveWhitespace 只会保留那些不在开始标签之后的空格，所以当空白作为标签的最后一个子节点存在时，也会被保留，如下代码所示：

`<div><span>test</span> <!-- 空白占位 -->  </div>`

如上代码中 `<span>` 标签的结束标签与 `<div>` 标签的结束标签之间存在一段空白，这段空白将会被保留。如果这段空白被保留那么就可能对布局产生影响，尤其是对行内元素的影响。为了消除这些影响带来的问题，好的做法是将它们去掉，而如代码就是用来完成这个工作的。

**comment 注释节点描述对象**

解析器是否会解析并保留注释节点，是由 shouldKeepComment 编译器选项决定的，开发者可以在创建Vue 实例的时候通过设置 comments 选项的值来控制编译器的shouldKeepComment 选项。默认情况下 comments 选项的值为 false ，即不保留注释，假如将其设置为 true ，则当解析器遇到注释节点时会保留该注释节点，此时 parseHTML 函数的 comment 钩子函数会被调用，如下：
```js
comment: function comment(text) {
	currentParent.children.push({
		type: 3,
		text: text,
		isComment: true
	});
}
```

要注意的是，普通文本节点与注释节点的元素描述对象的类型是一样的都是 3 ，不同的是注释节点的元素描述对象拥有 isComment 属性，并且该属性的值为 true，目的就是用来与普通文本节点作区分的。






















